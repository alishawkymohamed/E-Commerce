/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.3.1.0 (NJsonSchema v9.14.1.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class SwaggerClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param loginUser (optional) 
     * @return Success
     */
    api_Account_Login(loginUser: UserLoginDTO | null | undefined): Observable<AccessToken> {
        let url_ = this.baseUrl + "/api/Account/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(loginUser);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Account_Login(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Account_Login(<any>response_);
                } catch (e) {
                    return <Observable<AccessToken>><any>_observableThrow(e);
                }
            } else
                return <Observable<AccessToken>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Account_Login(response: HttpResponseBase): Observable<AccessToken> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AccessToken.fromJS(resultData200) : new AccessToken();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccessToken>(<any>null);
    }

    /**
     * @param jsonBody (optional) 
     * @return Success
     */
    api_Account_RefreshToken(jsonBody: any | null | undefined): Observable<AccessToken> {
        let url_ = this.baseUrl + "/api/Account/RefreshToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(jsonBody);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Account_RefreshToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Account_RefreshToken(<any>response_);
                } catch (e) {
                    return <Observable<AccessToken>><any>_observableThrow(e);
                }
            } else
                return <Observable<AccessToken>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Account_RefreshToken(response: HttpResponseBase): Observable<AccessToken> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AccessToken.fromJS(resultData200) : new AccessToken();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccessToken>(<any>null);
    }

    /**
     * @param refreshToken (optional) 
     * @return Success
     */
    api_Account_Logout(refreshToken: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Account/Logout?";
        if (refreshToken !== undefined)
            url_ += "refreshToken=" + encodeURIComponent("" + refreshToken) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Account_Logout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Account_Logout(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Account_Logout(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    api_Account_IsAuthenticated(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Account/IsAuthenticated";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Account_IsAuthenticated(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Account_IsAuthenticated(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Account_IsAuthenticated(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    api_Account_GetUserAuthTicket(): Observable<AuthTicketDTO> {
        let url_ = this.baseUrl + "/api/Account/GetUserAuthTicket";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Account_GetUserAuthTicket(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Account_GetUserAuthTicket(<any>response_);
                } catch (e) {
                    return <Observable<AuthTicketDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthTicketDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Account_GetUserAuthTicket(response: HttpResponseBase): Observable<AuthTicketDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthTicketDTO.fromJS(resultData200) : new AuthTicketDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthTicketDTO>(<any>null);
    }

    /**
     * @param registerUSerDTO (optional) 
     * @return Success
     */
    api_Account_Register(registerUSerDTO: RegisterUserDTO | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(registerUSerDTO);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Account_Register(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Account_Register(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Account_Register(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    api_Category_GetAll(take: number | null | undefined, skip: number | null | undefined, sort: any[] | null | undefined, filter_Field: string | null | undefined, filter_Operator: string | null | undefined, filter_Value: string | null | undefined, filter_Logic: string | null | undefined, filter_Filters: any[] | null | undefined, countless: boolean | null | undefined): Observable<DataSourceResultOfCategoryDTO> {
        let url_ = this.baseUrl + "/api/Category/GetAll?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Category_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Category_GetAll(<any>response_);
                } catch (e) {
                    return <Observable<DataSourceResultOfCategoryDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSourceResultOfCategoryDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Category_GetAll(response: HttpResponseBase): Observable<DataSourceResultOfCategoryDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataSourceResultOfCategoryDTO.fromJS(resultData200) : new DataSourceResultOfCategoryDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSourceResultOfCategoryDTO>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    api_Category_GetAllDetails(take: number | null | undefined, skip: number | null | undefined, sort: any[] | null | undefined, filter_Field: string | null | undefined, filter_Operator: string | null | undefined, filter_Value: string | null | undefined, filter_Logic: string | null | undefined, filter_Filters: any[] | null | undefined, countless: boolean | null | undefined): Observable<DataSourceResultOfCategoryDTO> {
        let url_ = this.baseUrl + "/api/Category/GetAllDetails?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Category_GetAllDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Category_GetAllDetails(<any>response_);
                } catch (e) {
                    return <Observable<DataSourceResultOfCategoryDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSourceResultOfCategoryDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Category_GetAllDetails(response: HttpResponseBase): Observable<DataSourceResultOfCategoryDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataSourceResultOfCategoryDTO.fromJS(resultData200) : new DataSourceResultOfCategoryDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSourceResultOfCategoryDTO>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    api_Category_GetById(id: string | null | undefined): Observable<CategoryDTO> {
        let url_ = this.baseUrl + "/api/Category/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Category_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Category_GetById(<any>response_);
                } catch (e) {
                    return <Observable<CategoryDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<CategoryDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Category_GetById(response: HttpResponseBase): Observable<CategoryDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CategoryDTO.fromJS(resultData200) : new CategoryDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryDTO>(<any>null);
    }

    /**
     * @param entities (optional) 
     * @return Success
     */
    api_Category_Insert(entities: CategoryDTO[] | null | undefined): Observable<CategoryDTO[]> {
        let url_ = this.baseUrl + "/api/Category/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entities);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Category_Insert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Category_Insert(<any>response_);
                } catch (e) {
                    return <Observable<CategoryDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CategoryDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Category_Insert(response: HttpResponseBase): Observable<CategoryDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CategoryDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryDTO[]>(<any>null);
    }

    /**
     * @param entities (optional) 
     * @return Success
     */
    api_Category_Update(entities: CategoryDTO[] | null | undefined): Observable<CategoryDTO[]> {
        let url_ = this.baseUrl + "/api/Category/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entities);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Category_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Category_Update(<any>response_);
                } catch (e) {
                    return <Observable<CategoryDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CategoryDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Category_Update(response: HttpResponseBase): Observable<CategoryDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CategoryDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryDTO[]>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    api_Category_Delete(ids: any[] | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/Category/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Category_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Category_Delete(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Category_Delete(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @param checkUniqueDTO (optional) 
     * @return Success
     */
    api_Category_IsExisted(checkUniqueDTO: CheckUniqueDTO | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Category/IsExisted";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(checkUniqueDTO);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Category_IsExisted(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Category_IsExisted(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Category_IsExisted(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    api_Localization_Json(culture: string): Observable<string> {
        let url_ = this.baseUrl + "/api/Localization/Json";
        if (culture === undefined || culture === null)
            throw new Error("The parameter 'culture' must be defined.");
        url_ = url_.replace("{culture}", encodeURIComponent("" + culture)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Localization_Json(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Localization_Json(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Localization_Json(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    api_Localization_GetLastUpDateTime(): Observable<Date> {
        let url_ = this.baseUrl + "/api/Localization/GetLastUpDateTime";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Localization_GetLastUpDateTime(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Localization_GetLastUpDateTime(<any>response_);
                } catch (e) {
                    return <Observable<Date>><any>_observableThrow(e);
                }
            } else
                return <Observable<Date>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Localization_GetLastUpDateTime(response: HttpResponseBase): Observable<Date> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? new Date(resultData200.toString()) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Date>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    api_Localization_GetAll(take: number | null | undefined, skip: number | null | undefined, sort: any[] | null | undefined, filter_Field: string | null | undefined, filter_Operator: string | null | undefined, filter_Value: string | null | undefined, filter_Logic: string | null | undefined, filter_Filters: any[] | null | undefined, countless: boolean | null | undefined): Observable<DataSourceResultOfLocalizationDetailsDTO> {
        let url_ = this.baseUrl + "/api/Localization/GetAll?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Localization_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Localization_GetAll(<any>response_);
                } catch (e) {
                    return <Observable<DataSourceResultOfLocalizationDetailsDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSourceResultOfLocalizationDetailsDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Localization_GetAll(response: HttpResponseBase): Observable<DataSourceResultOfLocalizationDetailsDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataSourceResultOfLocalizationDetailsDTO.fromJS(resultData200) : new DataSourceResultOfLocalizationDetailsDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSourceResultOfLocalizationDetailsDTO>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    api_Localization_GetAllDetails(take: number | null | undefined, skip: number | null | undefined, sort: any[] | null | undefined, filter_Field: string | null | undefined, filter_Operator: string | null | undefined, filter_Value: string | null | undefined, filter_Logic: string | null | undefined, filter_Filters: any[] | null | undefined, countless: boolean | null | undefined): Observable<DataSourceResultOfLocalizationDetailsDTO> {
        let url_ = this.baseUrl + "/api/Localization/GetAllDetails?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Localization_GetAllDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Localization_GetAllDetails(<any>response_);
                } catch (e) {
                    return <Observable<DataSourceResultOfLocalizationDetailsDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSourceResultOfLocalizationDetailsDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Localization_GetAllDetails(response: HttpResponseBase): Observable<DataSourceResultOfLocalizationDetailsDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataSourceResultOfLocalizationDetailsDTO.fromJS(resultData200) : new DataSourceResultOfLocalizationDetailsDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSourceResultOfLocalizationDetailsDTO>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    api_Localization_GetById(id: string | null | undefined): Observable<LocalizationDetailsDTO> {
        let url_ = this.baseUrl + "/api/Localization/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Localization_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Localization_GetById(<any>response_);
                } catch (e) {
                    return <Observable<LocalizationDetailsDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<LocalizationDetailsDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Localization_GetById(response: HttpResponseBase): Observable<LocalizationDetailsDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LocalizationDetailsDTO.fromJS(resultData200) : new LocalizationDetailsDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LocalizationDetailsDTO>(<any>null);
    }

    /**
     * @param entities (optional) 
     * @return Success
     */
    api_Localization_Insert(entities: LocalizationDetailsDTO[] | null | undefined): Observable<LocalizationDetailsDTO[]> {
        let url_ = this.baseUrl + "/api/Localization/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entities);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Localization_Insert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Localization_Insert(<any>response_);
                } catch (e) {
                    return <Observable<LocalizationDetailsDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LocalizationDetailsDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Localization_Insert(response: HttpResponseBase): Observable<LocalizationDetailsDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LocalizationDetailsDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LocalizationDetailsDTO[]>(<any>null);
    }

    /**
     * @param entities (optional) 
     * @return Success
     */
    api_Localization_Update(entities: LocalizationDetailsDTO[] | null | undefined): Observable<LocalizationDetailsDTO[]> {
        let url_ = this.baseUrl + "/api/Localization/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entities);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Localization_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Localization_Update(<any>response_);
                } catch (e) {
                    return <Observable<LocalizationDetailsDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LocalizationDetailsDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Localization_Update(response: HttpResponseBase): Observable<LocalizationDetailsDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LocalizationDetailsDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LocalizationDetailsDTO[]>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    api_Localization_Delete(ids: any[] | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/Localization/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Localization_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Localization_Delete(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Localization_Delete(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @param checkUniqueDTO (optional) 
     * @return Success
     */
    api_Localization_IsExisted(checkUniqueDTO: CheckUniqueDTO | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Localization/IsExisted";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(checkUniqueDTO);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Localization_IsExisted(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Localization_IsExisted(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Localization_IsExisted(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param type (optional) 
     * @param searchText (optional) 
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @param args (optional) 
     * @return Success
     */
    api_LookupAll(type: string | null | undefined, searchText: string | null | undefined, take: number | null | undefined, skip: number | null | undefined, sort: any[] | null | undefined, filter_Field: string | null | undefined, filter_Operator: string | null | undefined, filter_Value: string | null | undefined, filter_Logic: string | null | undefined, filter_Filters: any[] | null | undefined, countless: boolean | null | undefined, args: string | null | undefined): Observable<Lookup[]> {
        let url_ = this.baseUrl + "/api/Lookup?";
        if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        if (searchText !== undefined)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&"; 
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        if (args !== undefined)
            url_ += "args=" + encodeURIComponent("" + args) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_LookupAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_LookupAll(<any>response_);
                } catch (e) {
                    return <Observable<Lookup[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Lookup[]>><any>_observableThrow(response_);
        }));
    }

    protected processApi_LookupAll(response: HttpResponseBase): Observable<Lookup[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Lookup.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Lookup[]>(<any>null);
    }

    /**
     * @param type (optional) 
     * @param ids (optional) 
     * @return Success
     */
    api_Lookup(type: string | null | undefined, ids: any[] | null | undefined): Observable<Lookup[]> {
        let url_ = this.baseUrl + "/api/Lookup?";
        if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Lookup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Lookup(<any>response_);
                } catch (e) {
                    return <Observable<Lookup[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Lookup[]>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Lookup(response: HttpResponseBase): Observable<Lookup[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Lookup.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Lookup[]>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    api_Photo_GetAll(take: number | null | undefined, skip: number | null | undefined, sort: any[] | null | undefined, filter_Field: string | null | undefined, filter_Operator: string | null | undefined, filter_Value: string | null | undefined, filter_Logic: string | null | undefined, filter_Filters: any[] | null | undefined, countless: boolean | null | undefined): Observable<DataSourceResultOfPhotoDTO> {
        let url_ = this.baseUrl + "/api/Photo/GetAll?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Photo_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Photo_GetAll(<any>response_);
                } catch (e) {
                    return <Observable<DataSourceResultOfPhotoDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSourceResultOfPhotoDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Photo_GetAll(response: HttpResponseBase): Observable<DataSourceResultOfPhotoDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataSourceResultOfPhotoDTO.fromJS(resultData200) : new DataSourceResultOfPhotoDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSourceResultOfPhotoDTO>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    api_Photo_GetAllDetails(take: number | null | undefined, skip: number | null | undefined, sort: any[] | null | undefined, filter_Field: string | null | undefined, filter_Operator: string | null | undefined, filter_Value: string | null | undefined, filter_Logic: string | null | undefined, filter_Filters: any[] | null | undefined, countless: boolean | null | undefined): Observable<DataSourceResultOfPhotoDTO> {
        let url_ = this.baseUrl + "/api/Photo/GetAllDetails?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Photo_GetAllDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Photo_GetAllDetails(<any>response_);
                } catch (e) {
                    return <Observable<DataSourceResultOfPhotoDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSourceResultOfPhotoDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Photo_GetAllDetails(response: HttpResponseBase): Observable<DataSourceResultOfPhotoDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataSourceResultOfPhotoDTO.fromJS(resultData200) : new DataSourceResultOfPhotoDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSourceResultOfPhotoDTO>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    api_Photo_GetById(id: string | null | undefined): Observable<PhotoDTO> {
        let url_ = this.baseUrl + "/api/Photo/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Photo_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Photo_GetById(<any>response_);
                } catch (e) {
                    return <Observable<PhotoDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<PhotoDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Photo_GetById(response: HttpResponseBase): Observable<PhotoDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PhotoDTO.fromJS(resultData200) : new PhotoDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PhotoDTO>(<any>null);
    }

    /**
     * @param entities (optional) 
     * @return Success
     */
    api_Photo_Insert(entities: PhotoDTO[] | null | undefined): Observable<PhotoDTO[]> {
        let url_ = this.baseUrl + "/api/Photo/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entities);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Photo_Insert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Photo_Insert(<any>response_);
                } catch (e) {
                    return <Observable<PhotoDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PhotoDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Photo_Insert(response: HttpResponseBase): Observable<PhotoDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PhotoDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PhotoDTO[]>(<any>null);
    }

    /**
     * @param entities (optional) 
     * @return Success
     */
    api_Photo_Update(entities: PhotoDTO[] | null | undefined): Observable<PhotoDTO[]> {
        let url_ = this.baseUrl + "/api/Photo/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entities);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Photo_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Photo_Update(<any>response_);
                } catch (e) {
                    return <Observable<PhotoDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PhotoDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Photo_Update(response: HttpResponseBase): Observable<PhotoDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PhotoDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PhotoDTO[]>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    api_Photo_Delete(ids: any[] | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/Photo/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Photo_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Photo_Delete(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Photo_Delete(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @param checkUniqueDTO (optional) 
     * @return Success
     */
    api_Photo_IsExisted(checkUniqueDTO: CheckUniqueDTO | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Photo/IsExisted";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(checkUniqueDTO);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Photo_IsExisted(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Photo_IsExisted(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Photo_IsExisted(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    api_Product_GetAll(take: number | null | undefined, skip: number | null | undefined, sort: any[] | null | undefined, filter_Field: string | null | undefined, filter_Operator: string | null | undefined, filter_Value: string | null | undefined, filter_Logic: string | null | undefined, filter_Filters: any[] | null | undefined, countless: boolean | null | undefined): Observable<DataSourceResultOfProductDTO> {
        let url_ = this.baseUrl + "/api/Product/GetAll?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Product_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Product_GetAll(<any>response_);
                } catch (e) {
                    return <Observable<DataSourceResultOfProductDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSourceResultOfProductDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Product_GetAll(response: HttpResponseBase): Observable<DataSourceResultOfProductDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataSourceResultOfProductDTO.fromJS(resultData200) : new DataSourceResultOfProductDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSourceResultOfProductDTO>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    api_Product_GetAllDetails(take: number | null | undefined, skip: number | null | undefined, sort: any[] | null | undefined, filter_Field: string | null | undefined, filter_Operator: string | null | undefined, filter_Value: string | null | undefined, filter_Logic: string | null | undefined, filter_Filters: any[] | null | undefined, countless: boolean | null | undefined): Observable<DataSourceResultOfProductDTO> {
        let url_ = this.baseUrl + "/api/Product/GetAllDetails?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Product_GetAllDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Product_GetAllDetails(<any>response_);
                } catch (e) {
                    return <Observable<DataSourceResultOfProductDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSourceResultOfProductDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Product_GetAllDetails(response: HttpResponseBase): Observable<DataSourceResultOfProductDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataSourceResultOfProductDTO.fromJS(resultData200) : new DataSourceResultOfProductDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSourceResultOfProductDTO>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    api_Product_GetById(id: string | null | undefined): Observable<ProductDTO> {
        let url_ = this.baseUrl + "/api/Product/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Product_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Product_GetById(<any>response_);
                } catch (e) {
                    return <Observable<ProductDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Product_GetById(response: HttpResponseBase): Observable<ProductDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProductDTO.fromJS(resultData200) : new ProductDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductDTO>(<any>null);
    }

    /**
     * @param entities (optional) 
     * @return Success
     */
    api_Product_Insert(entities: ProductDTO[] | null | undefined): Observable<ProductDTO[]> {
        let url_ = this.baseUrl + "/api/Product/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entities);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Product_Insert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Product_Insert(<any>response_);
                } catch (e) {
                    return <Observable<ProductDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Product_Insert(response: HttpResponseBase): Observable<ProductDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductDTO[]>(<any>null);
    }

    /**
     * @param entities (optional) 
     * @return Success
     */
    api_Product_Update(entities: ProductDTO[] | null | undefined): Observable<ProductDTO[]> {
        let url_ = this.baseUrl + "/api/Product/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entities);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Product_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Product_Update(<any>response_);
                } catch (e) {
                    return <Observable<ProductDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Product_Update(response: HttpResponseBase): Observable<ProductDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductDTO[]>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    api_Product_Delete(ids: any[] | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/Product/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Product_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Product_Delete(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Product_Delete(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @param checkUniqueDTO (optional) 
     * @return Success
     */
    api_Product_IsExisted(checkUniqueDTO: CheckUniqueDTO | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Product/IsExisted";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(checkUniqueDTO);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Product_IsExisted(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Product_IsExisted(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Product_IsExisted(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    api_Role_GetAll(take: number | null | undefined, skip: number | null | undefined, sort: any[] | null | undefined, filter_Field: string | null | undefined, filter_Operator: string | null | undefined, filter_Value: string | null | undefined, filter_Logic: string | null | undefined, filter_Filters: any[] | null | undefined, countless: boolean | null | undefined): Observable<DataSourceResultOfRoleDTO> {
        let url_ = this.baseUrl + "/api/Role/GetAll?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Role_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Role_GetAll(<any>response_);
                } catch (e) {
                    return <Observable<DataSourceResultOfRoleDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSourceResultOfRoleDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Role_GetAll(response: HttpResponseBase): Observable<DataSourceResultOfRoleDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataSourceResultOfRoleDTO.fromJS(resultData200) : new DataSourceResultOfRoleDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSourceResultOfRoleDTO>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    api_Role_GetAllDetails(take: number | null | undefined, skip: number | null | undefined, sort: any[] | null | undefined, filter_Field: string | null | undefined, filter_Operator: string | null | undefined, filter_Value: string | null | undefined, filter_Logic: string | null | undefined, filter_Filters: any[] | null | undefined, countless: boolean | null | undefined): Observable<DataSourceResultOfRoleDTO> {
        let url_ = this.baseUrl + "/api/Role/GetAllDetails?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Role_GetAllDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Role_GetAllDetails(<any>response_);
                } catch (e) {
                    return <Observable<DataSourceResultOfRoleDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSourceResultOfRoleDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Role_GetAllDetails(response: HttpResponseBase): Observable<DataSourceResultOfRoleDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataSourceResultOfRoleDTO.fromJS(resultData200) : new DataSourceResultOfRoleDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSourceResultOfRoleDTO>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    api_Role_GetById(id: string | null | undefined): Observable<RoleDTO> {
        let url_ = this.baseUrl + "/api/Role/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Role_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Role_GetById(<any>response_);
                } catch (e) {
                    return <Observable<RoleDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Role_GetById(response: HttpResponseBase): Observable<RoleDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RoleDTO.fromJS(resultData200) : new RoleDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDTO>(<any>null);
    }

    /**
     * @param entities (optional) 
     * @return Success
     */
    api_Role_Insert(entities: RoleDTO[] | null | undefined): Observable<RoleDTO[]> {
        let url_ = this.baseUrl + "/api/Role/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entities);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Role_Insert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Role_Insert(<any>response_);
                } catch (e) {
                    return <Observable<RoleDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Role_Insert(response: HttpResponseBase): Observable<RoleDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RoleDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDTO[]>(<any>null);
    }

    /**
     * @param entities (optional) 
     * @return Success
     */
    api_Role_Update(entities: RoleDTO[] | null | undefined): Observable<RoleDTO[]> {
        let url_ = this.baseUrl + "/api/Role/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entities);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Role_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Role_Update(<any>response_);
                } catch (e) {
                    return <Observable<RoleDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Role_Update(response: HttpResponseBase): Observable<RoleDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RoleDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDTO[]>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    api_Role_Delete(ids: any[] | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/Role/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Role_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Role_Delete(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Role_Delete(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @param checkUniqueDTO (optional) 
     * @return Success
     */
    api_Role_IsExisted(checkUniqueDTO: CheckUniqueDTO | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Role/IsExisted";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(checkUniqueDTO);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Role_IsExisted(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Role_IsExisted(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Role_IsExisted(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    api_Specification_GetAll(take: number | null | undefined, skip: number | null | undefined, sort: any[] | null | undefined, filter_Field: string | null | undefined, filter_Operator: string | null | undefined, filter_Value: string | null | undefined, filter_Logic: string | null | undefined, filter_Filters: any[] | null | undefined, countless: boolean | null | undefined): Observable<DataSourceResultOfSpecificationDTO> {
        let url_ = this.baseUrl + "/api/Specification/GetAll?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Specification_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Specification_GetAll(<any>response_);
                } catch (e) {
                    return <Observable<DataSourceResultOfSpecificationDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSourceResultOfSpecificationDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Specification_GetAll(response: HttpResponseBase): Observable<DataSourceResultOfSpecificationDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataSourceResultOfSpecificationDTO.fromJS(resultData200) : new DataSourceResultOfSpecificationDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSourceResultOfSpecificationDTO>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    api_Specification_GetAllDetails(take: number | null | undefined, skip: number | null | undefined, sort: any[] | null | undefined, filter_Field: string | null | undefined, filter_Operator: string | null | undefined, filter_Value: string | null | undefined, filter_Logic: string | null | undefined, filter_Filters: any[] | null | undefined, countless: boolean | null | undefined): Observable<DataSourceResultOfSpecificationDTO> {
        let url_ = this.baseUrl + "/api/Specification/GetAllDetails?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Specification_GetAllDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Specification_GetAllDetails(<any>response_);
                } catch (e) {
                    return <Observable<DataSourceResultOfSpecificationDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSourceResultOfSpecificationDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Specification_GetAllDetails(response: HttpResponseBase): Observable<DataSourceResultOfSpecificationDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataSourceResultOfSpecificationDTO.fromJS(resultData200) : new DataSourceResultOfSpecificationDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSourceResultOfSpecificationDTO>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    api_Specification_GetById(id: string | null | undefined): Observable<SpecificationDTO> {
        let url_ = this.baseUrl + "/api/Specification/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Specification_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Specification_GetById(<any>response_);
                } catch (e) {
                    return <Observable<SpecificationDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<SpecificationDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Specification_GetById(response: HttpResponseBase): Observable<SpecificationDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SpecificationDTO.fromJS(resultData200) : new SpecificationDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SpecificationDTO>(<any>null);
    }

    /**
     * @param entities (optional) 
     * @return Success
     */
    api_Specification_Insert(entities: SpecificationDTO[] | null | undefined): Observable<SpecificationDTO[]> {
        let url_ = this.baseUrl + "/api/Specification/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entities);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Specification_Insert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Specification_Insert(<any>response_);
                } catch (e) {
                    return <Observable<SpecificationDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SpecificationDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Specification_Insert(response: HttpResponseBase): Observable<SpecificationDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SpecificationDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SpecificationDTO[]>(<any>null);
    }

    /**
     * @param entities (optional) 
     * @return Success
     */
    api_Specification_Update(entities: SpecificationDTO[] | null | undefined): Observable<SpecificationDTO[]> {
        let url_ = this.baseUrl + "/api/Specification/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entities);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Specification_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Specification_Update(<any>response_);
                } catch (e) {
                    return <Observable<SpecificationDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SpecificationDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Specification_Update(response: HttpResponseBase): Observable<SpecificationDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SpecificationDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SpecificationDTO[]>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    api_Specification_Delete(ids: any[] | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/Specification/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Specification_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Specification_Delete(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Specification_Delete(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @param checkUniqueDTO (optional) 
     * @return Success
     */
    api_Specification_IsExisted(checkUniqueDTO: CheckUniqueDTO | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Specification/IsExisted";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(checkUniqueDTO);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Specification_IsExisted(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Specification_IsExisted(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Specification_IsExisted(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    api_SubCategory_GetAll(take: number | null | undefined, skip: number | null | undefined, sort: any[] | null | undefined, filter_Field: string | null | undefined, filter_Operator: string | null | undefined, filter_Value: string | null | undefined, filter_Logic: string | null | undefined, filter_Filters: any[] | null | undefined, countless: boolean | null | undefined): Observable<DataSourceResultOfSubCategoryDTO> {
        let url_ = this.baseUrl + "/api/SubCategory/GetAll?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_SubCategory_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_SubCategory_GetAll(<any>response_);
                } catch (e) {
                    return <Observable<DataSourceResultOfSubCategoryDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSourceResultOfSubCategoryDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApi_SubCategory_GetAll(response: HttpResponseBase): Observable<DataSourceResultOfSubCategoryDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataSourceResultOfSubCategoryDTO.fromJS(resultData200) : new DataSourceResultOfSubCategoryDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSourceResultOfSubCategoryDTO>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    api_SubCategory_GetAllDetails(take: number | null | undefined, skip: number | null | undefined, sort: any[] | null | undefined, filter_Field: string | null | undefined, filter_Operator: string | null | undefined, filter_Value: string | null | undefined, filter_Logic: string | null | undefined, filter_Filters: any[] | null | undefined, countless: boolean | null | undefined): Observable<DataSourceResultOfSubCategoryDTO> {
        let url_ = this.baseUrl + "/api/SubCategory/GetAllDetails?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_SubCategory_GetAllDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_SubCategory_GetAllDetails(<any>response_);
                } catch (e) {
                    return <Observable<DataSourceResultOfSubCategoryDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSourceResultOfSubCategoryDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApi_SubCategory_GetAllDetails(response: HttpResponseBase): Observable<DataSourceResultOfSubCategoryDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataSourceResultOfSubCategoryDTO.fromJS(resultData200) : new DataSourceResultOfSubCategoryDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSourceResultOfSubCategoryDTO>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    api_SubCategory_GetById(id: string | null | undefined): Observable<SubCategoryDTO> {
        let url_ = this.baseUrl + "/api/SubCategory/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_SubCategory_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_SubCategory_GetById(<any>response_);
                } catch (e) {
                    return <Observable<SubCategoryDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubCategoryDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApi_SubCategory_GetById(response: HttpResponseBase): Observable<SubCategoryDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubCategoryDTO.fromJS(resultData200) : new SubCategoryDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubCategoryDTO>(<any>null);
    }

    /**
     * @param entities (optional) 
     * @return Success
     */
    api_SubCategory_Insert(entities: SubCategoryDTO[] | null | undefined): Observable<SubCategoryDTO[]> {
        let url_ = this.baseUrl + "/api/SubCategory/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entities);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_SubCategory_Insert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_SubCategory_Insert(<any>response_);
                } catch (e) {
                    return <Observable<SubCategoryDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubCategoryDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApi_SubCategory_Insert(response: HttpResponseBase): Observable<SubCategoryDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SubCategoryDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubCategoryDTO[]>(<any>null);
    }

    /**
     * @param entities (optional) 
     * @return Success
     */
    api_SubCategory_Update(entities: SubCategoryDTO[] | null | undefined): Observable<SubCategoryDTO[]> {
        let url_ = this.baseUrl + "/api/SubCategory/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entities);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_SubCategory_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_SubCategory_Update(<any>response_);
                } catch (e) {
                    return <Observable<SubCategoryDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubCategoryDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApi_SubCategory_Update(response: HttpResponseBase): Observable<SubCategoryDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SubCategoryDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubCategoryDTO[]>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    api_SubCategory_Delete(ids: any[] | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/SubCategory/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_SubCategory_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_SubCategory_Delete(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processApi_SubCategory_Delete(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @param checkUniqueDTO (optional) 
     * @return Success
     */
    api_SubCategory_IsExisted(checkUniqueDTO: CheckUniqueDTO | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/SubCategory/IsExisted";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(checkUniqueDTO);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_SubCategory_IsExisted(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_SubCategory_IsExisted(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApi_SubCategory_IsExisted(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param username (optional) 
     * @return Success
     */
    api_User_GetByUserName(username: string | null | undefined): Observable<UserDetailsDTO> {
        let url_ = this.baseUrl + "/api/User/GetByUserName?";
        if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_User_GetByUserName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_User_GetByUserName(<any>response_);
                } catch (e) {
                    return <Observable<UserDetailsDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDetailsDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApi_User_GetByUserName(response: HttpResponseBase): Observable<UserDetailsDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDetailsDTO.fromJS(resultData200) : new UserDetailsDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDetailsDTO>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    api_User_ChangeUserPassword(model: ChangePasswordViewModel | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/User/ChangeUserPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_User_ChangeUserPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_User_ChangeUserPassword(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processApi_User_ChangeUserPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    api_User_GetAll(take: number | null | undefined, skip: number | null | undefined, sort: any[] | null | undefined, filter_Field: string | null | undefined, filter_Operator: string | null | undefined, filter_Value: string | null | undefined, filter_Logic: string | null | undefined, filter_Filters: any[] | null | undefined, countless: boolean | null | undefined): Observable<DataSourceResultOfUserSummaryDTO> {
        let url_ = this.baseUrl + "/api/User/GetAll?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_User_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_User_GetAll(<any>response_);
                } catch (e) {
                    return <Observable<DataSourceResultOfUserSummaryDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSourceResultOfUserSummaryDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApi_User_GetAll(response: HttpResponseBase): Observable<DataSourceResultOfUserSummaryDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataSourceResultOfUserSummaryDTO.fromJS(resultData200) : new DataSourceResultOfUserSummaryDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSourceResultOfUserSummaryDTO>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    api_User_GetAllDetails(take: number | null | undefined, skip: number | null | undefined, sort: any[] | null | undefined, filter_Field: string | null | undefined, filter_Operator: string | null | undefined, filter_Value: string | null | undefined, filter_Logic: string | null | undefined, filter_Filters: any[] | null | undefined, countless: boolean | null | undefined): Observable<DataSourceResultOfUserDetailsDTO> {
        let url_ = this.baseUrl + "/api/User/GetAllDetails?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_User_GetAllDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_User_GetAllDetails(<any>response_);
                } catch (e) {
                    return <Observable<DataSourceResultOfUserDetailsDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSourceResultOfUserDetailsDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApi_User_GetAllDetails(response: HttpResponseBase): Observable<DataSourceResultOfUserDetailsDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataSourceResultOfUserDetailsDTO.fromJS(resultData200) : new DataSourceResultOfUserDetailsDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSourceResultOfUserDetailsDTO>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    api_User_GetById(id: string | null | undefined): Observable<UserDetailsDTO> {
        let url_ = this.baseUrl + "/api/User/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_User_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_User_GetById(<any>response_);
                } catch (e) {
                    return <Observable<UserDetailsDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDetailsDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApi_User_GetById(response: HttpResponseBase): Observable<UserDetailsDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDetailsDTO.fromJS(resultData200) : new UserDetailsDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDetailsDTO>(<any>null);
    }

    /**
     * @param entities (optional) 
     * @return Success
     */
    api_User_Insert(entities: UserDetailsDTO[] | null | undefined): Observable<UserDetailsDTO[]> {
        let url_ = this.baseUrl + "/api/User/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entities);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_User_Insert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_User_Insert(<any>response_);
                } catch (e) {
                    return <Observable<UserDetailsDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDetailsDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApi_User_Insert(response: HttpResponseBase): Observable<UserDetailsDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserDetailsDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDetailsDTO[]>(<any>null);
    }

    /**
     * @param entities (optional) 
     * @return Success
     */
    api_User_Update(entities: UserDetailsDTO[] | null | undefined): Observable<UserDetailsDTO[]> {
        let url_ = this.baseUrl + "/api/User/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entities);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_User_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_User_Update(<any>response_);
                } catch (e) {
                    return <Observable<UserDetailsDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDetailsDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApi_User_Update(response: HttpResponseBase): Observable<UserDetailsDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserDetailsDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDetailsDTO[]>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    api_User_Delete(ids: any[] | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/User/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_User_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_User_Delete(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processApi_User_Delete(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @param checkUniqueDTO (optional) 
     * @return Success
     */
    api_User_IsExisted(checkUniqueDTO: CheckUniqueDTO | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/User/IsExisted";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(checkUniqueDTO);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_User_IsExisted(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_User_IsExisted(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApi_User_IsExisted(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    api_UserRole_GetAll(take: number | null | undefined, skip: number | null | undefined, sort: any[] | null | undefined, filter_Field: string | null | undefined, filter_Operator: string | null | undefined, filter_Value: string | null | undefined, filter_Logic: string | null | undefined, filter_Filters: any[] | null | undefined, countless: boolean | null | undefined): Observable<DataSourceResultOfUserRoleDTO> {
        let url_ = this.baseUrl + "/api/UserRole/GetAll?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_UserRole_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_UserRole_GetAll(<any>response_);
                } catch (e) {
                    return <Observable<DataSourceResultOfUserRoleDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSourceResultOfUserRoleDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApi_UserRole_GetAll(response: HttpResponseBase): Observable<DataSourceResultOfUserRoleDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataSourceResultOfUserRoleDTO.fromJS(resultData200) : new DataSourceResultOfUserRoleDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSourceResultOfUserRoleDTO>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    api_UserRole_GetAllDetails(take: number | null | undefined, skip: number | null | undefined, sort: any[] | null | undefined, filter_Field: string | null | undefined, filter_Operator: string | null | undefined, filter_Value: string | null | undefined, filter_Logic: string | null | undefined, filter_Filters: any[] | null | undefined, countless: boolean | null | undefined): Observable<DataSourceResultOfUserRoleDTO> {
        let url_ = this.baseUrl + "/api/UserRole/GetAllDetails?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_UserRole_GetAllDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_UserRole_GetAllDetails(<any>response_);
                } catch (e) {
                    return <Observable<DataSourceResultOfUserRoleDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSourceResultOfUserRoleDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApi_UserRole_GetAllDetails(response: HttpResponseBase): Observable<DataSourceResultOfUserRoleDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataSourceResultOfUserRoleDTO.fromJS(resultData200) : new DataSourceResultOfUserRoleDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSourceResultOfUserRoleDTO>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    api_UserRole_GetById(id: string | null | undefined): Observable<UserRoleDTO> {
        let url_ = this.baseUrl + "/api/UserRole/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_UserRole_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_UserRole_GetById(<any>response_);
                } catch (e) {
                    return <Observable<UserRoleDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserRoleDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApi_UserRole_GetById(response: HttpResponseBase): Observable<UserRoleDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserRoleDTO.fromJS(resultData200) : new UserRoleDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserRoleDTO>(<any>null);
    }

    /**
     * @param entities (optional) 
     * @return Success
     */
    api_UserRole_Insert(entities: UserRoleDTO[] | null | undefined): Observable<UserRoleDTO[]> {
        let url_ = this.baseUrl + "/api/UserRole/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entities);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_UserRole_Insert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_UserRole_Insert(<any>response_);
                } catch (e) {
                    return <Observable<UserRoleDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserRoleDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApi_UserRole_Insert(response: HttpResponseBase): Observable<UserRoleDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserRoleDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserRoleDTO[]>(<any>null);
    }

    /**
     * @param entities (optional) 
     * @return Success
     */
    api_UserRole_Update(entities: UserRoleDTO[] | null | undefined): Observable<UserRoleDTO[]> {
        let url_ = this.baseUrl + "/api/UserRole/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entities);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_UserRole_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_UserRole_Update(<any>response_);
                } catch (e) {
                    return <Observable<UserRoleDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserRoleDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApi_UserRole_Update(response: HttpResponseBase): Observable<UserRoleDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserRoleDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserRoleDTO[]>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    api_UserRole_Delete(ids: any[] | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/UserRole/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_UserRole_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_UserRole_Delete(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processApi_UserRole_Delete(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @param checkUniqueDTO (optional) 
     * @return Success
     */
    api_UserRole_IsExisted(checkUniqueDTO: CheckUniqueDTO | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/UserRole/IsExisted";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(checkUniqueDTO);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_UserRole_IsExisted(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_UserRole_IsExisted(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApi_UserRole_IsExisted(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

export class UserLoginDTO implements IUserLoginDTO {
    username!: string;
    password!: string;

    constructor(data?: IUserLoginDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.username = data["Username"];
            this.password = data["Password"];
        }
    }

    static fromJS(data: any): UserLoginDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Username"] = this.username;
        data["Password"] = this.password;
        return data; 
    }
}

export interface IUserLoginDTO {
    username: string;
    password: string;
}

export class AccessToken implements IAccessToken {
    access_token?: string | undefined;
    refresh_token?: string | undefined;

    constructor(data?: IAccessToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.access_token = data["access_token"];
            this.refresh_token = data["refresh_token"];
        }
    }

    static fromJS(data: any): AccessToken {
        data = typeof data === 'object' ? data : {};
        let result = new AccessToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["access_token"] = this.access_token;
        data["refresh_token"] = this.refresh_token;
        return data; 
    }
}

export interface IAccessToken {
    access_token?: string | undefined;
    refresh_token?: string | undefined;
}

export class AuthTicketDTO implements IAuthTicketDTO {
    userId?: number | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    fullName?: string | undefined;
    profileImageFileId?: number | undefined;
    roleId?: number | undefined;
    roleName?: string | undefined;
    defaultCulture?: string | undefined;
    userRoles?: UserRoleDTO[] | undefined;

    constructor(data?: IAuthTicketDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["UserId"];
            this.userName = data["UserName"];
            this.email = data["Email"];
            this.fullName = data["FullName"];
            this.profileImageFileId = data["ProfileImageFileId"];
            this.roleId = data["RoleId"];
            this.roleName = data["RoleName"];
            this.defaultCulture = data["DefaultCulture"];
            if (data["UserRoles"] && data["UserRoles"].constructor === Array) {
                this.userRoles = [] as any;
                for (let item of data["UserRoles"])
                    this.userRoles!.push(UserRoleDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AuthTicketDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AuthTicketDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserId"] = this.userId;
        data["UserName"] = this.userName;
        data["Email"] = this.email;
        data["FullName"] = this.fullName;
        data["ProfileImageFileId"] = this.profileImageFileId;
        data["RoleId"] = this.roleId;
        data["RoleName"] = this.roleName;
        data["DefaultCulture"] = this.defaultCulture;
        if (this.userRoles && this.userRoles.constructor === Array) {
            data["UserRoles"] = [];
            for (let item of this.userRoles)
                data["UserRoles"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAuthTicketDTO {
    userId?: number | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    fullName?: string | undefined;
    profileImageFileId?: number | undefined;
    roleId?: number | undefined;
    roleName?: string | undefined;
    defaultCulture?: string | undefined;
    userRoles?: UserRoleDTO[] | undefined;
}

export class UserRoleDTO implements IUserRoleDTO {
    userId?: number | undefined;
    roleId?: number | undefined;
    roleName?: string | undefined;
    userName?: string | undefined;
    notes?: string | undefined;

    constructor(data?: IUserRoleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["UserId"];
            this.roleId = data["RoleId"];
            this.roleName = data["RoleName"];
            this.userName = data["UserName"];
            this.notes = data["Notes"];
        }
    }

    static fromJS(data: any): UserRoleDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserId"] = this.userId;
        data["RoleId"] = this.roleId;
        data["RoleName"] = this.roleName;
        data["UserName"] = this.userName;
        data["Notes"] = this.notes;
        return data; 
    }
}

export interface IUserRoleDTO {
    userId?: number | undefined;
    roleId?: number | undefined;
    roleName?: string | undefined;
    userName?: string | undefined;
    notes?: string | undefined;
}

export class RegisterUserDTO implements IRegisterUserDTO {
    fullName?: string | undefined;
    username?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;
    confirmPassword?: string | undefined;
    roleId?: number | undefined;

    constructor(data?: IRegisterUserDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fullName = data["FullName"];
            this.username = data["Username"];
            this.email = data["Email"];
            this.password = data["Password"];
            this.confirmPassword = data["ConfirmPassword"];
            this.roleId = data["RoleId"];
        }
    }

    static fromJS(data: any): RegisterUserDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterUserDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["FullName"] = this.fullName;
        data["Username"] = this.username;
        data["Email"] = this.email;
        data["Password"] = this.password;
        data["ConfirmPassword"] = this.confirmPassword;
        data["RoleId"] = this.roleId;
        return data; 
    }
}

export interface IRegisterUserDTO {
    fullName?: string | undefined;
    username?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;
    confirmPassword?: string | undefined;
    roleId?: number | undefined;
}

export class Sort implements ISort {
    field?: string | undefined;
    dir?: string | undefined;

    constructor(data?: ISort) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.field = data["Field"];
            this.dir = data["Dir"];
        }
    }

    static fromJS(data: any): Sort {
        data = typeof data === 'object' ? data : {};
        let result = new Sort();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Field"] = this.field;
        data["Dir"] = this.dir;
        return data; 
    }
}

export interface ISort {
    field?: string | undefined;
    dir?: string | undefined;
}

export class Filter implements IFilter {
    field?: string | undefined;
    operator?: string | undefined;
    value?: string | undefined;
    logic?: string | undefined;
    filters?: Filter[] | undefined;

    constructor(data?: IFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.field = data["Field"];
            this.operator = data["Operator"];
            this.value = data["Value"];
            this.logic = data["Logic"];
            if (data["Filters"] && data["Filters"].constructor === Array) {
                this.filters = [] as any;
                for (let item of data["Filters"])
                    this.filters!.push(Filter.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Filter {
        data = typeof data === 'object' ? data : {};
        let result = new Filter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Field"] = this.field;
        data["Operator"] = this.operator;
        data["Value"] = this.value;
        data["Logic"] = this.logic;
        if (this.filters && this.filters.constructor === Array) {
            data["Filters"] = [];
            for (let item of this.filters)
                data["Filters"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IFilter {
    field?: string | undefined;
    operator?: string | undefined;
    value?: string | undefined;
    logic?: string | undefined;
    filters?: Filter[] | undefined;
}

export class DataSourceResultOfCategoryDTO implements IDataSourceResultOfCategoryDTO {
    data?: CategoryDTO[] | undefined;
    count?: number | undefined;

    constructor(data?: IDataSourceResultOfCategoryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["Data"] && data["Data"].constructor === Array) {
                this.data = [] as any;
                for (let item of data["Data"])
                    this.data!.push(CategoryDTO.fromJS(item));
            }
            this.count = data["Count"];
        }
    }

    static fromJS(data: any): DataSourceResultOfCategoryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DataSourceResultOfCategoryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["Data"] = [];
            for (let item of this.data)
                data["Data"].push(item.toJSON());
        }
        data["Count"] = this.count;
        return data; 
    }
}

export interface IDataSourceResultOfCategoryDTO {
    data?: CategoryDTO[] | undefined;
    count?: number | undefined;
}

export class CategoryDTO implements ICategoryDTO {
    categoryId?: number | undefined;
    categoryNameAr?: string | undefined;
    categoryNameEn?: string | undefined;
    categoryName?: string | undefined;
    categoryCode?: string | undefined;

    constructor(data?: ICategoryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.categoryId = data["CategoryId"];
            this.categoryNameAr = data["CategoryNameAr"];
            this.categoryNameEn = data["CategoryNameEn"];
            this.categoryName = data["CategoryName"];
            this.categoryCode = data["CategoryCode"];
        }
    }

    static fromJS(data: any): CategoryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["CategoryId"] = this.categoryId;
        data["CategoryNameAr"] = this.categoryNameAr;
        data["CategoryNameEn"] = this.categoryNameEn;
        data["CategoryName"] = this.categoryName;
        data["CategoryCode"] = this.categoryCode;
        return data; 
    }
}

export interface ICategoryDTO {
    categoryId?: number | undefined;
    categoryNameAr?: string | undefined;
    categoryNameEn?: string | undefined;
    categoryName?: string | undefined;
    categoryCode?: string | undefined;
}

export class CheckUniqueDTO implements ICheckUniqueDTO {
    tableName?: string | undefined;
    fields?: string[] | undefined;
    values?: string[] | undefined;

    constructor(data?: ICheckUniqueDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tableName = data["TableName"];
            if (data["Fields"] && data["Fields"].constructor === Array) {
                this.fields = [] as any;
                for (let item of data["Fields"])
                    this.fields!.push(item);
            }
            if (data["Values"] && data["Values"].constructor === Array) {
                this.values = [] as any;
                for (let item of data["Values"])
                    this.values!.push(item);
            }
        }
    }

    static fromJS(data: any): CheckUniqueDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CheckUniqueDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TableName"] = this.tableName;
        if (this.fields && this.fields.constructor === Array) {
            data["Fields"] = [];
            for (let item of this.fields)
                data["Fields"].push(item);
        }
        if (this.values && this.values.constructor === Array) {
            data["Values"] = [];
            for (let item of this.values)
                data["Values"].push(item);
        }
        return data; 
    }
}

export interface ICheckUniqueDTO {
    tableName?: string | undefined;
    fields?: string[] | undefined;
    values?: string[] | undefined;
}

export class DataSourceResultOfLocalizationDetailsDTO implements IDataSourceResultOfLocalizationDetailsDTO {
    data?: LocalizationDetailsDTO[] | undefined;
    count?: number | undefined;

    constructor(data?: IDataSourceResultOfLocalizationDetailsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["Data"] && data["Data"].constructor === Array) {
                this.data = [] as any;
                for (let item of data["Data"])
                    this.data!.push(LocalizationDetailsDTO.fromJS(item));
            }
            this.count = data["Count"];
        }
    }

    static fromJS(data: any): DataSourceResultOfLocalizationDetailsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DataSourceResultOfLocalizationDetailsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["Data"] = [];
            for (let item of this.data)
                data["Data"].push(item.toJSON());
        }
        data["Count"] = this.count;
        return data; 
    }
}

export interface IDataSourceResultOfLocalizationDetailsDTO {
    data?: LocalizationDetailsDTO[] | undefined;
    count?: number | undefined;
}

export class LocalizationDetailsDTO implements ILocalizationDetailsDTO {
    localizationId?: number | undefined;
    key?: string | undefined;
    valueAr?: string | undefined;
    valueEn?: string | undefined;

    constructor(data?: ILocalizationDetailsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.localizationId = data["LocalizationId"];
            this.key = data["Key"];
            this.valueAr = data["ValueAr"];
            this.valueEn = data["ValueEn"];
        }
    }

    static fromJS(data: any): LocalizationDetailsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizationDetailsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["LocalizationId"] = this.localizationId;
        data["Key"] = this.key;
        data["ValueAr"] = this.valueAr;
        data["ValueEn"] = this.valueEn;
        return data; 
    }
}

export interface ILocalizationDetailsDTO {
    localizationId?: number | undefined;
    key?: string | undefined;
    valueAr?: string | undefined;
    valueEn?: string | undefined;
}

export class Lookup implements ILookup {
    id?: any | undefined;
    textAr?: string | undefined;
    textEn?: string | undefined;
    children?: Lookup[] | undefined;
    additional?: LookupAdditional | undefined;

    constructor(data?: ILookup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.textAr = data["TextAr"];
            this.textEn = data["TextEn"];
            if (data["Children"] && data["Children"].constructor === Array) {
                this.children = [] as any;
                for (let item of data["Children"])
                    this.children!.push(Lookup.fromJS(item));
            }
            this.additional = data["Additional"] ? LookupAdditional.fromJS(data["Additional"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Lookup {
        data = typeof data === 'object' ? data : {};
        let result = new Lookup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["TextAr"] = this.textAr;
        data["TextEn"] = this.textEn;
        if (this.children && this.children.constructor === Array) {
            data["Children"] = [];
            for (let item of this.children)
                data["Children"].push(item.toJSON());
        }
        data["Additional"] = this.additional ? this.additional.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ILookup {
    id?: any | undefined;
    textAr?: string | undefined;
    textEn?: string | undefined;
    children?: Lookup[] | undefined;
    additional?: LookupAdditional | undefined;
}

export class LookupAdditional implements ILookupAdditional {
    description?: string | undefined;
    imageId?: number | undefined;
    imageUrl?: string | undefined;
    image?: string | undefined;
    ancestors?: Lookup[] | undefined;
    data?: any | undefined;

    constructor(data?: ILookupAdditional) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["Description"];
            this.imageId = data["ImageId"];
            this.imageUrl = data["ImageUrl"];
            this.image = data["Image"];
            if (data["Ancestors"] && data["Ancestors"].constructor === Array) {
                this.ancestors = [] as any;
                for (let item of data["Ancestors"])
                    this.ancestors!.push(Lookup.fromJS(item));
            }
            this.data = data["Data"];
        }
    }

    static fromJS(data: any): LookupAdditional {
        data = typeof data === 'object' ? data : {};
        let result = new LookupAdditional();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Description"] = this.description;
        data["ImageId"] = this.imageId;
        data["ImageUrl"] = this.imageUrl;
        data["Image"] = this.image;
        if (this.ancestors && this.ancestors.constructor === Array) {
            data["Ancestors"] = [];
            for (let item of this.ancestors)
                data["Ancestors"].push(item.toJSON());
        }
        data["Data"] = this.data;
        return data; 
    }
}

export interface ILookupAdditional {
    description?: string | undefined;
    imageId?: number | undefined;
    imageUrl?: string | undefined;
    image?: string | undefined;
    ancestors?: Lookup[] | undefined;
    data?: any | undefined;
}

export class DataSourceResultOfPhotoDTO implements IDataSourceResultOfPhotoDTO {
    data?: PhotoDTO[] | undefined;
    count?: number | undefined;

    constructor(data?: IDataSourceResultOfPhotoDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["Data"] && data["Data"].constructor === Array) {
                this.data = [] as any;
                for (let item of data["Data"])
                    this.data!.push(PhotoDTO.fromJS(item));
            }
            this.count = data["Count"];
        }
    }

    static fromJS(data: any): DataSourceResultOfPhotoDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DataSourceResultOfPhotoDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["Data"] = [];
            for (let item of this.data)
                data["Data"].push(item.toJSON());
        }
        data["Count"] = this.count;
        return data; 
    }
}

export interface IDataSourceResultOfPhotoDTO {
    data?: PhotoDTO[] | undefined;
    count?: number | undefined;
}

export class PhotoDTO implements IPhotoDTO {
    photoId?: number | undefined;
    base64String?: string | undefined;
    extension?: string | undefined;
    path?: string | undefined;
    uniqueName?: string | undefined;
    isMainPhoto?: boolean | undefined;
    isRealPhoto?: boolean | undefined;
    isCommercialPhoto?: boolean | undefined;
    productId?: number | undefined;

    constructor(data?: IPhotoDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.photoId = data["PhotoId"];
            this.base64String = data["Base64String"];
            this.extension = data["Extension"];
            this.path = data["Path"];
            this.uniqueName = data["UniqueName"];
            this.isMainPhoto = data["IsMainPhoto"];
            this.isRealPhoto = data["IsRealPhoto"];
            this.isCommercialPhoto = data["IsCommercialPhoto"];
            this.productId = data["ProductId"];
        }
    }

    static fromJS(data: any): PhotoDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PhotoDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PhotoId"] = this.photoId;
        data["Base64String"] = this.base64String;
        data["Extension"] = this.extension;
        data["Path"] = this.path;
        data["UniqueName"] = this.uniqueName;
        data["IsMainPhoto"] = this.isMainPhoto;
        data["IsRealPhoto"] = this.isRealPhoto;
        data["IsCommercialPhoto"] = this.isCommercialPhoto;
        data["ProductId"] = this.productId;
        return data; 
    }
}

export interface IPhotoDTO {
    photoId?: number | undefined;
    base64String?: string | undefined;
    extension?: string | undefined;
    path?: string | undefined;
    uniqueName?: string | undefined;
    isMainPhoto?: boolean | undefined;
    isRealPhoto?: boolean | undefined;
    isCommercialPhoto?: boolean | undefined;
    productId?: number | undefined;
}

export class DataSourceResultOfProductDTO implements IDataSourceResultOfProductDTO {
    data?: ProductDTO[] | undefined;
    count?: number | undefined;

    constructor(data?: IDataSourceResultOfProductDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["Data"] && data["Data"].constructor === Array) {
                this.data = [] as any;
                for (let item of data["Data"])
                    this.data!.push(ProductDTO.fromJS(item));
            }
            this.count = data["Count"];
        }
    }

    static fromJS(data: any): DataSourceResultOfProductDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DataSourceResultOfProductDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["Data"] = [];
            for (let item of this.data)
                data["Data"].push(item.toJSON());
        }
        data["Count"] = this.count;
        return data; 
    }
}

export interface IDataSourceResultOfProductDTO {
    data?: ProductDTO[] | undefined;
    count?: number | undefined;
}

export class ProductDTO implements IProductDTO {
    productId?: number | undefined;
    productNameAr?: string | undefined;
    productNameEn?: string | undefined;
    readonly productName?: string | undefined;
    code?: string | undefined;
    price?: number | undefined;
    deduction?: number | undefined;
    isApproved?: boolean | undefined;
    readonly priceAfterDeduction?: number | undefined;
    userId?: number | undefined;
    subCategoryId?: number | undefined;
    specifications?: SpecificationDTO[] | undefined;
    photos?: PhotoDTO[] | undefined;

    constructor(data?: IProductDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.productId = data["ProductId"];
            this.productNameAr = data["ProductNameAr"];
            this.productNameEn = data["ProductNameEn"];
            (<any>this).productName = data["ProductName"];
            this.code = data["Code"];
            this.price = data["Price"];
            this.deduction = data["Deduction"];
            this.isApproved = data["IsApproved"];
            (<any>this).priceAfterDeduction = data["PriceAfterDeduction"];
            this.userId = data["UserId"];
            this.subCategoryId = data["SubCategoryId"];
            if (data["Specifications"] && data["Specifications"].constructor === Array) {
                this.specifications = [] as any;
                for (let item of data["Specifications"])
                    this.specifications!.push(SpecificationDTO.fromJS(item));
            }
            if (data["Photos"] && data["Photos"].constructor === Array) {
                this.photos = [] as any;
                for (let item of data["Photos"])
                    this.photos!.push(PhotoDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ProductId"] = this.productId;
        data["ProductNameAr"] = this.productNameAr;
        data["ProductNameEn"] = this.productNameEn;
        data["ProductName"] = this.productName;
        data["Code"] = this.code;
        data["Price"] = this.price;
        data["Deduction"] = this.deduction;
        data["IsApproved"] = this.isApproved;
        data["PriceAfterDeduction"] = this.priceAfterDeduction;
        data["UserId"] = this.userId;
        data["SubCategoryId"] = this.subCategoryId;
        if (this.specifications && this.specifications.constructor === Array) {
            data["Specifications"] = [];
            for (let item of this.specifications)
                data["Specifications"].push(item.toJSON());
        }
        if (this.photos && this.photos.constructor === Array) {
            data["Photos"] = [];
            for (let item of this.photos)
                data["Photos"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProductDTO {
    productId?: number | undefined;
    productNameAr?: string | undefined;
    productNameEn?: string | undefined;
    productName?: string | undefined;
    code?: string | undefined;
    price?: number | undefined;
    deduction?: number | undefined;
    isApproved?: boolean | undefined;
    priceAfterDeduction?: number | undefined;
    userId?: number | undefined;
    subCategoryId?: number | undefined;
    specifications?: SpecificationDTO[] | undefined;
    photos?: PhotoDTO[] | undefined;
}

export class SpecificationDTO implements ISpecificationDTO {
    specificationId?: number | undefined;
    specificationNameAr?: string | undefined;
    specificationNameEn?: string | undefined;
    readonly specificationName?: string | undefined;
    specificationValueAr?: string | undefined;
    specificationValueEn?: string | undefined;
    readonly specificationValue?: string | undefined;
    productId?: number | undefined;

    constructor(data?: ISpecificationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.specificationId = data["SpecificationId"];
            this.specificationNameAr = data["SpecificationNameAr"];
            this.specificationNameEn = data["SpecificationNameEn"];
            (<any>this).specificationName = data["SpecificationName"];
            this.specificationValueAr = data["SpecificationValueAr"];
            this.specificationValueEn = data["SpecificationValueEn"];
            (<any>this).specificationValue = data["SpecificationValue"];
            this.productId = data["ProductId"];
        }
    }

    static fromJS(data: any): SpecificationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SpecificationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SpecificationId"] = this.specificationId;
        data["SpecificationNameAr"] = this.specificationNameAr;
        data["SpecificationNameEn"] = this.specificationNameEn;
        data["SpecificationName"] = this.specificationName;
        data["SpecificationValueAr"] = this.specificationValueAr;
        data["SpecificationValueEn"] = this.specificationValueEn;
        data["SpecificationValue"] = this.specificationValue;
        data["ProductId"] = this.productId;
        return data; 
    }
}

export interface ISpecificationDTO {
    specificationId?: number | undefined;
    specificationNameAr?: string | undefined;
    specificationNameEn?: string | undefined;
    specificationName?: string | undefined;
    specificationValueAr?: string | undefined;
    specificationValueEn?: string | undefined;
    specificationValue?: string | undefined;
    productId?: number | undefined;
}

export class DataSourceResultOfRoleDTO implements IDataSourceResultOfRoleDTO {
    data?: RoleDTO[] | undefined;
    count?: number | undefined;

    constructor(data?: IDataSourceResultOfRoleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["Data"] && data["Data"].constructor === Array) {
                this.data = [] as any;
                for (let item of data["Data"])
                    this.data!.push(RoleDTO.fromJS(item));
            }
            this.count = data["Count"];
        }
    }

    static fromJS(data: any): DataSourceResultOfRoleDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DataSourceResultOfRoleDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["Data"] = [];
            for (let item of this.data)
                data["Data"].push(item.toJSON());
        }
        data["Count"] = this.count;
        return data; 
    }
}

export interface IDataSourceResultOfRoleDTO {
    data?: RoleDTO[] | undefined;
    count?: number | undefined;
}

export class RoleDTO implements IRoleDTO {
    roleId?: number | undefined;
    roleName?: string | undefined;
    roleNameAr?: string | undefined;
    roleNameEn?: string | undefined;

    constructor(data?: IRoleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["RoleId"];
            this.roleName = data["RoleName"];
            this.roleNameAr = data["RoleNameAr"];
            this.roleNameEn = data["RoleNameEn"];
        }
    }

    static fromJS(data: any): RoleDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["RoleId"] = this.roleId;
        data["RoleName"] = this.roleName;
        data["RoleNameAr"] = this.roleNameAr;
        data["RoleNameEn"] = this.roleNameEn;
        return data; 
    }
}

export interface IRoleDTO {
    roleId?: number | undefined;
    roleName?: string | undefined;
    roleNameAr?: string | undefined;
    roleNameEn?: string | undefined;
}

export class DataSourceResultOfSpecificationDTO implements IDataSourceResultOfSpecificationDTO {
    data?: SpecificationDTO[] | undefined;
    count?: number | undefined;

    constructor(data?: IDataSourceResultOfSpecificationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["Data"] && data["Data"].constructor === Array) {
                this.data = [] as any;
                for (let item of data["Data"])
                    this.data!.push(SpecificationDTO.fromJS(item));
            }
            this.count = data["Count"];
        }
    }

    static fromJS(data: any): DataSourceResultOfSpecificationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DataSourceResultOfSpecificationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["Data"] = [];
            for (let item of this.data)
                data["Data"].push(item.toJSON());
        }
        data["Count"] = this.count;
        return data; 
    }
}

export interface IDataSourceResultOfSpecificationDTO {
    data?: SpecificationDTO[] | undefined;
    count?: number | undefined;
}

export class DataSourceResultOfSubCategoryDTO implements IDataSourceResultOfSubCategoryDTO {
    data?: SubCategoryDTO[] | undefined;
    count?: number | undefined;

    constructor(data?: IDataSourceResultOfSubCategoryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["Data"] && data["Data"].constructor === Array) {
                this.data = [] as any;
                for (let item of data["Data"])
                    this.data!.push(SubCategoryDTO.fromJS(item));
            }
            this.count = data["Count"];
        }
    }

    static fromJS(data: any): DataSourceResultOfSubCategoryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DataSourceResultOfSubCategoryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["Data"] = [];
            for (let item of this.data)
                data["Data"].push(item.toJSON());
        }
        data["Count"] = this.count;
        return data; 
    }
}

export interface IDataSourceResultOfSubCategoryDTO {
    data?: SubCategoryDTO[] | undefined;
    count?: number | undefined;
}

export class SubCategoryDTO implements ISubCategoryDTO {
    subCategoryId?: number | undefined;
    subCategoryNameAr?: string | undefined;
    subCategoryNameEn?: string | undefined;
    subCategoryName?: string | undefined;
    subCategoryCode?: string | undefined;
    categoryId?: number | undefined;

    constructor(data?: ISubCategoryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.subCategoryId = data["SubCategoryId"];
            this.subCategoryNameAr = data["SubCategoryNameAr"];
            this.subCategoryNameEn = data["SubCategoryNameEn"];
            this.subCategoryName = data["SubCategoryName"];
            this.subCategoryCode = data["SubCategoryCode"];
            this.categoryId = data["CategoryId"];
        }
    }

    static fromJS(data: any): SubCategoryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SubCategoryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SubCategoryId"] = this.subCategoryId;
        data["SubCategoryNameAr"] = this.subCategoryNameAr;
        data["SubCategoryNameEn"] = this.subCategoryNameEn;
        data["SubCategoryName"] = this.subCategoryName;
        data["SubCategoryCode"] = this.subCategoryCode;
        data["CategoryId"] = this.categoryId;
        return data; 
    }
}

export interface ISubCategoryDTO {
    subCategoryId?: number | undefined;
    subCategoryNameAr?: string | undefined;
    subCategoryNameEn?: string | undefined;
    subCategoryName?: string | undefined;
    subCategoryCode?: string | undefined;
    categoryId?: number | undefined;
}

export class UserDetailsDTO implements IUserDetailsDTO {
    userId?: number | undefined;
    concurrencyStamp?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    faxNumber?: string | undefined;
    userName?: string | undefined;
    fullNameEn?: string | undefined;
    fullNameAr?: string | undefined;
    enabled?: boolean | undefined;
    enabledUntil?: Date | undefined;
    profileImage?: string | undefined;
    signatureFileId?: number | undefined;
    trkeenFileId?: number | undefined;
    stampFileId?: number | undefined;
    employeeNumber?: string | undefined;
    sSN?: string | undefined;
    passportNumber?: string | undefined;
    password?: string | undefined;
    iqamaNumber?: string | undefined;
    genderId?: number | undefined;
    genderName?: string | undefined;
    nationalityId?: number | undefined;
    nationalityName?: string | undefined;
    jobTitleId?: number | undefined;
    jobTitleName?: string | undefined;
    workPlaceId?: number | undefined;
    workPlaceName?: string | undefined;
    address?: string | undefined;
    defaultCulture?: string | undefined;
    defaultCalendar?: string | undefined;
    workPhoneNumber?: string | undefined;
    notificationByMail?: boolean | undefined;
    notificationBySMS?: boolean | undefined;
    isIndividual?: boolean | undefined;
    isEmployee?: boolean | undefined;
    isCorrespondentForAllOrganizations?: boolean | undefined;

    constructor(data?: IUserDetailsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["UserId"];
            this.concurrencyStamp = data["ConcurrencyStamp"];
            this.email = data["Email"];
            this.phoneNumber = data["PhoneNumber"];
            this.faxNumber = data["FaxNumber"];
            this.userName = data["UserName"];
            this.fullNameEn = data["FullNameEn"];
            this.fullNameAr = data["FullNameAr"];
            this.enabled = data["Enabled"];
            this.enabledUntil = data["EnabledUntil"] ? new Date(data["EnabledUntil"].toString()) : <any>undefined;
            this.profileImage = data["ProfileImage"];
            this.signatureFileId = data["SignatureFileId"];
            this.trkeenFileId = data["TrkeenFileId"];
            this.stampFileId = data["StampFileId"];
            this.employeeNumber = data["EmployeeNumber"];
            this.sSN = data["SSN"];
            this.passportNumber = data["PassportNumber"];
            this.password = data["Password"];
            this.iqamaNumber = data["IqamaNumber"];
            this.genderId = data["GenderId"];
            this.genderName = data["GenderName"];
            this.nationalityId = data["NationalityId"];
            this.nationalityName = data["NationalityName"];
            this.jobTitleId = data["JobTitleId"];
            this.jobTitleName = data["JobTitleName"];
            this.workPlaceId = data["WorkPlaceId"];
            this.workPlaceName = data["WorkPlaceName"];
            this.address = data["Address"];
            this.defaultCulture = data["DefaultCulture"];
            this.defaultCalendar = data["DefaultCalendar"];
            this.workPhoneNumber = data["WorkPhoneNumber"];
            this.notificationByMail = data["NotificationByMail"];
            this.notificationBySMS = data["NotificationBySMS"];
            this.isIndividual = data["IsIndividual"];
            this.isEmployee = data["IsEmployee"];
            this.isCorrespondentForAllOrganizations = data["IsCorrespondentForAllOrganizations"];
        }
    }

    static fromJS(data: any): UserDetailsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UserDetailsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserId"] = this.userId;
        data["ConcurrencyStamp"] = this.concurrencyStamp;
        data["Email"] = this.email;
        data["PhoneNumber"] = this.phoneNumber;
        data["FaxNumber"] = this.faxNumber;
        data["UserName"] = this.userName;
        data["FullNameEn"] = this.fullNameEn;
        data["FullNameAr"] = this.fullNameAr;
        data["Enabled"] = this.enabled;
        data["EnabledUntil"] = this.enabledUntil ? this.enabledUntil.toISOString() : <any>undefined;
        data["ProfileImage"] = this.profileImage;
        data["SignatureFileId"] = this.signatureFileId;
        data["TrkeenFileId"] = this.trkeenFileId;
        data["StampFileId"] = this.stampFileId;
        data["EmployeeNumber"] = this.employeeNumber;
        data["SSN"] = this.sSN;
        data["PassportNumber"] = this.passportNumber;
        data["Password"] = this.password;
        data["IqamaNumber"] = this.iqamaNumber;
        data["GenderId"] = this.genderId;
        data["GenderName"] = this.genderName;
        data["NationalityId"] = this.nationalityId;
        data["NationalityName"] = this.nationalityName;
        data["JobTitleId"] = this.jobTitleId;
        data["JobTitleName"] = this.jobTitleName;
        data["WorkPlaceId"] = this.workPlaceId;
        data["WorkPlaceName"] = this.workPlaceName;
        data["Address"] = this.address;
        data["DefaultCulture"] = this.defaultCulture;
        data["DefaultCalendar"] = this.defaultCalendar;
        data["WorkPhoneNumber"] = this.workPhoneNumber;
        data["NotificationByMail"] = this.notificationByMail;
        data["NotificationBySMS"] = this.notificationBySMS;
        data["IsIndividual"] = this.isIndividual;
        data["IsEmployee"] = this.isEmployee;
        data["IsCorrespondentForAllOrganizations"] = this.isCorrespondentForAllOrganizations;
        return data; 
    }
}

export interface IUserDetailsDTO {
    userId?: number | undefined;
    concurrencyStamp?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    faxNumber?: string | undefined;
    userName?: string | undefined;
    fullNameEn?: string | undefined;
    fullNameAr?: string | undefined;
    enabled?: boolean | undefined;
    enabledUntil?: Date | undefined;
    profileImage?: string | undefined;
    signatureFileId?: number | undefined;
    trkeenFileId?: number | undefined;
    stampFileId?: number | undefined;
    employeeNumber?: string | undefined;
    sSN?: string | undefined;
    passportNumber?: string | undefined;
    password?: string | undefined;
    iqamaNumber?: string | undefined;
    genderId?: number | undefined;
    genderName?: string | undefined;
    nationalityId?: number | undefined;
    nationalityName?: string | undefined;
    jobTitleId?: number | undefined;
    jobTitleName?: string | undefined;
    workPlaceId?: number | undefined;
    workPlaceName?: string | undefined;
    address?: string | undefined;
    defaultCulture?: string | undefined;
    defaultCalendar?: string | undefined;
    workPhoneNumber?: string | undefined;
    notificationByMail?: boolean | undefined;
    notificationBySMS?: boolean | undefined;
    isIndividual?: boolean | undefined;
    isEmployee?: boolean | undefined;
    isCorrespondentForAllOrganizations?: boolean | undefined;
}

export class ChangePasswordViewModel implements IChangePasswordViewModel {
    oldPassword!: string;
    newPassword!: string;
    confirmPassword!: string;

    constructor(data?: IChangePasswordViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.oldPassword = data["OldPassword"];
            this.newPassword = data["NewPassword"];
            this.confirmPassword = data["ConfirmPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["OldPassword"] = this.oldPassword;
        data["NewPassword"] = this.newPassword;
        data["ConfirmPassword"] = this.confirmPassword;
        return data; 
    }
}

export interface IChangePasswordViewModel {
    oldPassword: string;
    newPassword: string;
    confirmPassword: string;
}

export class DataSourceResultOfUserSummaryDTO implements IDataSourceResultOfUserSummaryDTO {
    data?: UserSummaryDTO[] | undefined;
    count?: number | undefined;

    constructor(data?: IDataSourceResultOfUserSummaryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["Data"] && data["Data"].constructor === Array) {
                this.data = [] as any;
                for (let item of data["Data"])
                    this.data!.push(UserSummaryDTO.fromJS(item));
            }
            this.count = data["Count"];
        }
    }

    static fromJS(data: any): DataSourceResultOfUserSummaryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DataSourceResultOfUserSummaryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["Data"] = [];
            for (let item of this.data)
                data["Data"].push(item.toJSON());
        }
        data["Count"] = this.count;
        return data; 
    }
}

export interface IDataSourceResultOfUserSummaryDTO {
    data?: UserSummaryDTO[] | undefined;
    count?: number | undefined;
}

export class UserSummaryDTO implements IUserSummaryDTO {
    id?: number | undefined;
    userName?: string | undefined;
    fullName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    enabled?: boolean | undefined;
    profileImage?: string | undefined;

    constructor(data?: IUserSummaryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.userName = data["UserName"];
            this.fullName = data["FullName"];
            this.email = data["Email"];
            this.phoneNumber = data["PhoneNumber"];
            this.enabled = data["Enabled"];
            this.profileImage = data["ProfileImage"];
        }
    }

    static fromJS(data: any): UserSummaryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UserSummaryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["UserName"] = this.userName;
        data["FullName"] = this.fullName;
        data["Email"] = this.email;
        data["PhoneNumber"] = this.phoneNumber;
        data["Enabled"] = this.enabled;
        data["ProfileImage"] = this.profileImage;
        return data; 
    }
}

export interface IUserSummaryDTO {
    id?: number | undefined;
    userName?: string | undefined;
    fullName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    enabled?: boolean | undefined;
    profileImage?: string | undefined;
}

export class DataSourceResultOfUserDetailsDTO implements IDataSourceResultOfUserDetailsDTO {
    data?: UserDetailsDTO[] | undefined;
    count?: number | undefined;

    constructor(data?: IDataSourceResultOfUserDetailsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["Data"] && data["Data"].constructor === Array) {
                this.data = [] as any;
                for (let item of data["Data"])
                    this.data!.push(UserDetailsDTO.fromJS(item));
            }
            this.count = data["Count"];
        }
    }

    static fromJS(data: any): DataSourceResultOfUserDetailsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DataSourceResultOfUserDetailsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["Data"] = [];
            for (let item of this.data)
                data["Data"].push(item.toJSON());
        }
        data["Count"] = this.count;
        return data; 
    }
}

export interface IDataSourceResultOfUserDetailsDTO {
    data?: UserDetailsDTO[] | undefined;
    count?: number | undefined;
}

export class DataSourceResultOfUserRoleDTO implements IDataSourceResultOfUserRoleDTO {
    data?: UserRoleDTO[] | undefined;
    count?: number | undefined;

    constructor(data?: IDataSourceResultOfUserRoleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["Data"] && data["Data"].constructor === Array) {
                this.data = [] as any;
                for (let item of data["Data"])
                    this.data!.push(UserRoleDTO.fromJS(item));
            }
            this.count = data["Count"];
        }
    }

    static fromJS(data: any): DataSourceResultOfUserRoleDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DataSourceResultOfUserRoleDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["Data"] = [];
            for (let item of this.data)
                data["Data"].push(item.toJSON());
        }
        data["Count"] = this.count;
        return data; 
    }
}

export interface IDataSourceResultOfUserRoleDTO {
    data?: UserRoleDTO[] | undefined;
    count?: number | undefined;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}