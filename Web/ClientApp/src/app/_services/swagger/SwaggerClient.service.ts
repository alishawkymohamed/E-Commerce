/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.0.13.0 (NJsonSchema v9.13.17.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class SwaggerClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param loginUser (optional) 
     * @return Success
     */
    api_Account_Login(loginUser: UserLoginDTO | null | undefined): Observable<AccessToken> {
        let url_ = this.baseUrl + "/api/Account/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(loginUser);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Account_Login(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Account_Login(<any>response_);
                } catch (e) {
                    return <Observable<AccessToken>><any>_observableThrow(e);
                }
            } else
                return <Observable<AccessToken>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Account_Login(response: HttpResponseBase): Observable<AccessToken> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AccessToken.fromJS(resultData200) : new AccessToken();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccessToken>(<any>null);
    }

    /**
     * @param jsonBody (optional) 
     * @return Success
     */
    api_Account_RefreshToken(jsonBody: any | null | undefined): Observable<AccessToken> {
        let url_ = this.baseUrl + "/api/Account/RefreshToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(jsonBody);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Account_RefreshToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Account_RefreshToken(<any>response_);
                } catch (e) {
                    return <Observable<AccessToken>><any>_observableThrow(e);
                }
            } else
                return <Observable<AccessToken>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Account_RefreshToken(response: HttpResponseBase): Observable<AccessToken> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AccessToken.fromJS(resultData200) : new AccessToken();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccessToken>(<any>null);
    }

    /**
     * @param refreshToken (optional) 
     * @return Success
     */
    api_Account_Logout(refreshToken: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Account/Logout?";
        if (refreshToken !== undefined)
            url_ += "refreshToken=" + encodeURIComponent("" + refreshToken) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Account_Logout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Account_Logout(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Account_Logout(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    api_Account_IsAuthenticated(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Account/IsAuthenticated";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Account_IsAuthenticated(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Account_IsAuthenticated(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Account_IsAuthenticated(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param organizationId (optional) 
     * @param roleId (optional) 
     * @return Success
     */
    api_Account_GetUserAuthTicket(organizationId: number | null | undefined, roleId: number | null | undefined): Observable<AuthTicketDTO> {
        let url_ = this.baseUrl + "/api/Account/GetUserAuthTicket?";
        if (organizationId !== undefined)
            url_ += "organizationId=" + encodeURIComponent("" + organizationId) + "&"; 
        if (roleId !== undefined)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Account_GetUserAuthTicket(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Account_GetUserAuthTicket(<any>response_);
                } catch (e) {
                    return <Observable<AuthTicketDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthTicketDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Account_GetUserAuthTicket(response: HttpResponseBase): Observable<AuthTicketDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthTicketDTO.fromJS(resultData200) : new AuthTicketDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthTicketDTO>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    api_Category_GetAll(take: number | null | undefined, skip: number | null | undefined, sort: any[] | null | undefined, filter_Field: string | null | undefined, filter_Operator: string | null | undefined, filter_Value: string | null | undefined, filter_Logic: string | null | undefined, filter_Filters: any[] | null | undefined, countless: boolean | null | undefined): Observable<DataSourceResultOfCategoryDTO> {
        let url_ = this.baseUrl + "/api/Category/GetAll?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Category_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Category_GetAll(<any>response_);
                } catch (e) {
                    return <Observable<DataSourceResultOfCategoryDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSourceResultOfCategoryDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Category_GetAll(response: HttpResponseBase): Observable<DataSourceResultOfCategoryDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataSourceResultOfCategoryDTO.fromJS(resultData200) : new DataSourceResultOfCategoryDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSourceResultOfCategoryDTO>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    api_Category_GetAllDetails(take: number | null | undefined, skip: number | null | undefined, sort: any[] | null | undefined, filter_Field: string | null | undefined, filter_Operator: string | null | undefined, filter_Value: string | null | undefined, filter_Logic: string | null | undefined, filter_Filters: any[] | null | undefined, countless: boolean | null | undefined): Observable<DataSourceResultOfCategoryDTO> {
        let url_ = this.baseUrl + "/api/Category/GetAllDetails?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Category_GetAllDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Category_GetAllDetails(<any>response_);
                } catch (e) {
                    return <Observable<DataSourceResultOfCategoryDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSourceResultOfCategoryDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Category_GetAllDetails(response: HttpResponseBase): Observable<DataSourceResultOfCategoryDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataSourceResultOfCategoryDTO.fromJS(resultData200) : new DataSourceResultOfCategoryDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSourceResultOfCategoryDTO>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    api_Category_GetById(id: string | null | undefined): Observable<CategoryDTO> {
        let url_ = this.baseUrl + "/api/Category/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Category_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Category_GetById(<any>response_);
                } catch (e) {
                    return <Observable<CategoryDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<CategoryDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Category_GetById(response: HttpResponseBase): Observable<CategoryDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CategoryDTO.fromJS(resultData200) : new CategoryDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryDTO>(<any>null);
    }

    /**
     * @param entities (optional) 
     * @return Success
     */
    api_Category_Insert(entities: CategoryDTO[] | null | undefined): Observable<CategoryDTO[]> {
        let url_ = this.baseUrl + "/api/Category/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entities);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Category_Insert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Category_Insert(<any>response_);
                } catch (e) {
                    return <Observable<CategoryDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CategoryDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Category_Insert(response: HttpResponseBase): Observable<CategoryDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CategoryDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryDTO[]>(<any>null);
    }

    /**
     * @param entities (optional) 
     * @return Success
     */
    api_Category_Update(entities: CategoryDTO[] | null | undefined): Observable<CategoryDTO[]> {
        let url_ = this.baseUrl + "/api/Category/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entities);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Category_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Category_Update(<any>response_);
                } catch (e) {
                    return <Observable<CategoryDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CategoryDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Category_Update(response: HttpResponseBase): Observable<CategoryDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CategoryDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryDTO[]>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    api_Category_Delete(ids: any[] | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/Category/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Category_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Category_Delete(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Category_Delete(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @param checkUniqueDTO (optional) 
     * @return Success
     */
    api_Category_IsExisted(checkUniqueDTO: CheckUniqueDTO | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Category/IsExisted";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(checkUniqueDTO);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Category_IsExisted(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Category_IsExisted(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Category_IsExisted(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    api_Localization_json(culture: string): Observable<string> {
        let url_ = this.baseUrl + "/api/Localization/json";
        if (culture === undefined || culture === null)
            throw new Error("The parameter 'culture' must be defined.");
        url_ = url_.replace("{culture}", encodeURIComponent("" + culture)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Localization_json(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Localization_json(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Localization_json(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    api_Localization_GetLastUpDateTime(): Observable<Date> {
        let url_ = this.baseUrl + "/api/Localization/GetLastUpDateTime";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Localization_GetLastUpDateTime(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Localization_GetLastUpDateTime(<any>response_);
                } catch (e) {
                    return <Observable<Date>><any>_observableThrow(e);
                }
            } else
                return <Observable<Date>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Localization_GetLastUpDateTime(response: HttpResponseBase): Observable<Date> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? new Date(resultData200.toString()) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Date>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    api_Localization_GetAll(take: number | null | undefined, skip: number | null | undefined, sort: any[] | null | undefined, filter_Field: string | null | undefined, filter_Operator: string | null | undefined, filter_Value: string | null | undefined, filter_Logic: string | null | undefined, filter_Filters: any[] | null | undefined, countless: boolean | null | undefined): Observable<DataSourceResultOfLocalizationDetailsDTO> {
        let url_ = this.baseUrl + "/api/Localization/GetAll?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Localization_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Localization_GetAll(<any>response_);
                } catch (e) {
                    return <Observable<DataSourceResultOfLocalizationDetailsDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSourceResultOfLocalizationDetailsDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Localization_GetAll(response: HttpResponseBase): Observable<DataSourceResultOfLocalizationDetailsDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataSourceResultOfLocalizationDetailsDTO.fromJS(resultData200) : new DataSourceResultOfLocalizationDetailsDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSourceResultOfLocalizationDetailsDTO>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    api_Localization_GetAllDetails(take: number | null | undefined, skip: number | null | undefined, sort: any[] | null | undefined, filter_Field: string | null | undefined, filter_Operator: string | null | undefined, filter_Value: string | null | undefined, filter_Logic: string | null | undefined, filter_Filters: any[] | null | undefined, countless: boolean | null | undefined): Observable<DataSourceResultOfLocalizationDetailsDTO> {
        let url_ = this.baseUrl + "/api/Localization/GetAllDetails?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Localization_GetAllDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Localization_GetAllDetails(<any>response_);
                } catch (e) {
                    return <Observable<DataSourceResultOfLocalizationDetailsDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSourceResultOfLocalizationDetailsDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Localization_GetAllDetails(response: HttpResponseBase): Observable<DataSourceResultOfLocalizationDetailsDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataSourceResultOfLocalizationDetailsDTO.fromJS(resultData200) : new DataSourceResultOfLocalizationDetailsDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSourceResultOfLocalizationDetailsDTO>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    api_Localization_GetById(id: string | null | undefined): Observable<LocalizationDetailsDTO> {
        let url_ = this.baseUrl + "/api/Localization/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Localization_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Localization_GetById(<any>response_);
                } catch (e) {
                    return <Observable<LocalizationDetailsDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<LocalizationDetailsDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Localization_GetById(response: HttpResponseBase): Observable<LocalizationDetailsDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LocalizationDetailsDTO.fromJS(resultData200) : new LocalizationDetailsDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LocalizationDetailsDTO>(<any>null);
    }

    /**
     * @param entities (optional) 
     * @return Success
     */
    api_Localization_Insert(entities: LocalizationDetailsDTO[] | null | undefined): Observable<LocalizationDetailsDTO[]> {
        let url_ = this.baseUrl + "/api/Localization/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entities);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Localization_Insert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Localization_Insert(<any>response_);
                } catch (e) {
                    return <Observable<LocalizationDetailsDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LocalizationDetailsDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Localization_Insert(response: HttpResponseBase): Observable<LocalizationDetailsDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LocalizationDetailsDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LocalizationDetailsDTO[]>(<any>null);
    }

    /**
     * @param entities (optional) 
     * @return Success
     */
    api_Localization_Update(entities: LocalizationDetailsDTO[] | null | undefined): Observable<LocalizationDetailsDTO[]> {
        let url_ = this.baseUrl + "/api/Localization/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entities);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Localization_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Localization_Update(<any>response_);
                } catch (e) {
                    return <Observable<LocalizationDetailsDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LocalizationDetailsDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Localization_Update(response: HttpResponseBase): Observable<LocalizationDetailsDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LocalizationDetailsDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LocalizationDetailsDTO[]>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    api_Localization_Delete(ids: any[] | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/Localization/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Localization_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Localization_Delete(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Localization_Delete(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @param checkUniqueDTO (optional) 
     * @return Success
     */
    api_Localization_IsExisted(checkUniqueDTO: CheckUniqueDTO | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Localization/IsExisted";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(checkUniqueDTO);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Localization_IsExisted(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Localization_IsExisted(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Localization_IsExisted(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param type (optional) 
     * @param searchText (optional) 
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @param args (optional) 
     * @return Success
     */
    api_LookupAll(type: string | null | undefined, searchText: string | null | undefined, take: number | null | undefined, skip: number | null | undefined, sort: any[] | null | undefined, filter_Field: string | null | undefined, filter_Operator: string | null | undefined, filter_Value: string | null | undefined, filter_Logic: string | null | undefined, filter_Filters: any[] | null | undefined, countless: boolean | null | undefined, args: string | null | undefined): Observable<Lookup[]> {
        let url_ = this.baseUrl + "/api/Lookup?";
        if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        if (searchText !== undefined)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&"; 
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        if (args !== undefined)
            url_ += "args=" + encodeURIComponent("" + args) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_LookupAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_LookupAll(<any>response_);
                } catch (e) {
                    return <Observable<Lookup[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Lookup[]>><any>_observableThrow(response_);
        }));
    }

    protected processApi_LookupAll(response: HttpResponseBase): Observable<Lookup[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Lookup.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Lookup[]>(<any>null);
    }

    /**
     * @param type (optional) 
     * @param ids (optional) 
     * @return Success
     */
    api_Lookup(type: string | null | undefined, ids: any[] | null | undefined): Observable<Lookup[]> {
        let url_ = this.baseUrl + "/api/Lookup?";
        if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Lookup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Lookup(<any>response_);
                } catch (e) {
                    return <Observable<Lookup[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Lookup[]>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Lookup(response: HttpResponseBase): Observable<Lookup[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Lookup.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Lookup[]>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    api_Role_GetAll(take: number | null | undefined, skip: number | null | undefined, sort: any[] | null | undefined, filter_Field: string | null | undefined, filter_Operator: string | null | undefined, filter_Value: string | null | undefined, filter_Logic: string | null | undefined, filter_Filters: any[] | null | undefined, countless: boolean | null | undefined): Observable<DataSourceResultOfRoleDTO> {
        let url_ = this.baseUrl + "/api/Role/GetAll?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Role_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Role_GetAll(<any>response_);
                } catch (e) {
                    return <Observable<DataSourceResultOfRoleDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSourceResultOfRoleDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Role_GetAll(response: HttpResponseBase): Observable<DataSourceResultOfRoleDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataSourceResultOfRoleDTO.fromJS(resultData200) : new DataSourceResultOfRoleDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSourceResultOfRoleDTO>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    api_Role_GetAllDetails(take: number | null | undefined, skip: number | null | undefined, sort: any[] | null | undefined, filter_Field: string | null | undefined, filter_Operator: string | null | undefined, filter_Value: string | null | undefined, filter_Logic: string | null | undefined, filter_Filters: any[] | null | undefined, countless: boolean | null | undefined): Observable<DataSourceResultOfRoleDTO> {
        let url_ = this.baseUrl + "/api/Role/GetAllDetails?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Role_GetAllDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Role_GetAllDetails(<any>response_);
                } catch (e) {
                    return <Observable<DataSourceResultOfRoleDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSourceResultOfRoleDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Role_GetAllDetails(response: HttpResponseBase): Observable<DataSourceResultOfRoleDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataSourceResultOfRoleDTO.fromJS(resultData200) : new DataSourceResultOfRoleDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSourceResultOfRoleDTO>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    api_Role_GetById(id: string | null | undefined): Observable<RoleDTO> {
        let url_ = this.baseUrl + "/api/Role/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Role_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Role_GetById(<any>response_);
                } catch (e) {
                    return <Observable<RoleDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Role_GetById(response: HttpResponseBase): Observable<RoleDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RoleDTO.fromJS(resultData200) : new RoleDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDTO>(<any>null);
    }

    /**
     * @param entities (optional) 
     * @return Success
     */
    api_Role_Insert(entities: RoleDTO[] | null | undefined): Observable<RoleDTO[]> {
        let url_ = this.baseUrl + "/api/Role/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entities);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Role_Insert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Role_Insert(<any>response_);
                } catch (e) {
                    return <Observable<RoleDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Role_Insert(response: HttpResponseBase): Observable<RoleDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RoleDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDTO[]>(<any>null);
    }

    /**
     * @param entities (optional) 
     * @return Success
     */
    api_Role_Update(entities: RoleDTO[] | null | undefined): Observable<RoleDTO[]> {
        let url_ = this.baseUrl + "/api/Role/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entities);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Role_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Role_Update(<any>response_);
                } catch (e) {
                    return <Observable<RoleDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Role_Update(response: HttpResponseBase): Observable<RoleDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RoleDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDTO[]>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    api_Role_Delete(ids: any[] | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/Role/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Role_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Role_Delete(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Role_Delete(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @param checkUniqueDTO (optional) 
     * @return Success
     */
    api_Role_IsExisted(checkUniqueDTO: CheckUniqueDTO | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Role/IsExisted";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(checkUniqueDTO);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_Role_IsExisted(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_Role_IsExisted(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApi_Role_IsExisted(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param username (optional) 
     * @return Success
     */
    api_User_GetByUserName(username: string | null | undefined): Observable<UserDetailsDTO> {
        let url_ = this.baseUrl + "/api/User/GetByUserName?";
        if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_User_GetByUserName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_User_GetByUserName(<any>response_);
                } catch (e) {
                    return <Observable<UserDetailsDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDetailsDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApi_User_GetByUserName(response: HttpResponseBase): Observable<UserDetailsDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDetailsDTO.fromJS(resultData200) : new UserDetailsDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDetailsDTO>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    api_User_ChangeUserPassword(model: ChangePasswordViewModel | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/User/ChangeUserPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_User_ChangeUserPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_User_ChangeUserPassword(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processApi_User_ChangeUserPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    api_User_GetAll(take: number | null | undefined, skip: number | null | undefined, sort: any[] | null | undefined, filter_Field: string | null | undefined, filter_Operator: string | null | undefined, filter_Value: string | null | undefined, filter_Logic: string | null | undefined, filter_Filters: any[] | null | undefined, countless: boolean | null | undefined): Observable<DataSourceResultOfUserSummaryDTO> {
        let url_ = this.baseUrl + "/api/User/GetAll?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_User_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_User_GetAll(<any>response_);
                } catch (e) {
                    return <Observable<DataSourceResultOfUserSummaryDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSourceResultOfUserSummaryDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApi_User_GetAll(response: HttpResponseBase): Observable<DataSourceResultOfUserSummaryDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataSourceResultOfUserSummaryDTO.fromJS(resultData200) : new DataSourceResultOfUserSummaryDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSourceResultOfUserSummaryDTO>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    api_User_GetAllDetails(take: number | null | undefined, skip: number | null | undefined, sort: any[] | null | undefined, filter_Field: string | null | undefined, filter_Operator: string | null | undefined, filter_Value: string | null | undefined, filter_Logic: string | null | undefined, filter_Filters: any[] | null | undefined, countless: boolean | null | undefined): Observable<DataSourceResultOfUserDetailsDTO> {
        let url_ = this.baseUrl + "/api/User/GetAllDetails?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_User_GetAllDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_User_GetAllDetails(<any>response_);
                } catch (e) {
                    return <Observable<DataSourceResultOfUserDetailsDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSourceResultOfUserDetailsDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApi_User_GetAllDetails(response: HttpResponseBase): Observable<DataSourceResultOfUserDetailsDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataSourceResultOfUserDetailsDTO.fromJS(resultData200) : new DataSourceResultOfUserDetailsDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSourceResultOfUserDetailsDTO>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    api_User_GetById(id: string | null | undefined): Observable<UserDetailsDTO> {
        let url_ = this.baseUrl + "/api/User/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_User_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_User_GetById(<any>response_);
                } catch (e) {
                    return <Observable<UserDetailsDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDetailsDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApi_User_GetById(response: HttpResponseBase): Observable<UserDetailsDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDetailsDTO.fromJS(resultData200) : new UserDetailsDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDetailsDTO>(<any>null);
    }

    /**
     * @param entities (optional) 
     * @return Success
     */
    api_User_Insert(entities: UserDetailsDTO[] | null | undefined): Observable<UserDetailsDTO[]> {
        let url_ = this.baseUrl + "/api/User/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entities);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_User_Insert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_User_Insert(<any>response_);
                } catch (e) {
                    return <Observable<UserDetailsDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDetailsDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApi_User_Insert(response: HttpResponseBase): Observable<UserDetailsDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserDetailsDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDetailsDTO[]>(<any>null);
    }

    /**
     * @param entities (optional) 
     * @return Success
     */
    api_User_Update(entities: UserDetailsDTO[] | null | undefined): Observable<UserDetailsDTO[]> {
        let url_ = this.baseUrl + "/api/User/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entities);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_User_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_User_Update(<any>response_);
                } catch (e) {
                    return <Observable<UserDetailsDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDetailsDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApi_User_Update(response: HttpResponseBase): Observable<UserDetailsDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserDetailsDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDetailsDTO[]>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    api_User_Delete(ids: any[] | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/User/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_User_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_User_Delete(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processApi_User_Delete(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @param checkUniqueDTO (optional) 
     * @return Success
     */
    api_User_IsExisted(checkUniqueDTO: CheckUniqueDTO | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/User/IsExisted";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(checkUniqueDTO);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_User_IsExisted(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_User_IsExisted(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApi_User_IsExisted(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    api_UserRole_GetAll(take: number | null | undefined, skip: number | null | undefined, sort: any[] | null | undefined, filter_Field: string | null | undefined, filter_Operator: string | null | undefined, filter_Value: string | null | undefined, filter_Logic: string | null | undefined, filter_Filters: any[] | null | undefined, countless: boolean | null | undefined): Observable<DataSourceResultOfUserRoleDTO> {
        let url_ = this.baseUrl + "/api/UserRole/GetAll?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_UserRole_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_UserRole_GetAll(<any>response_);
                } catch (e) {
                    return <Observable<DataSourceResultOfUserRoleDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSourceResultOfUserRoleDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApi_UserRole_GetAll(response: HttpResponseBase): Observable<DataSourceResultOfUserRoleDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataSourceResultOfUserRoleDTO.fromJS(resultData200) : new DataSourceResultOfUserRoleDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSourceResultOfUserRoleDTO>(<any>null);
    }

    /**
     * @param take (optional) 
     * @param skip (optional) 
     * @param sort (optional) 
     * @param filter_Field (optional) 
     * @param filter_Operator (optional) 
     * @param filter_Value (optional) 
     * @param filter_Logic (optional) 
     * @param filter_Filters (optional) 
     * @param countless (optional) 
     * @return Success
     */
    api_UserRole_GetAllDetails(take: number | null | undefined, skip: number | null | undefined, sort: any[] | null | undefined, filter_Field: string | null | undefined, filter_Operator: string | null | undefined, filter_Value: string | null | undefined, filter_Logic: string | null | undefined, filter_Filters: any[] | null | undefined, countless: boolean | null | undefined): Observable<DataSourceResultOfUserRoleDTO> {
        let url_ = this.baseUrl + "/api/UserRole/GetAllDetails?";
        if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&"; 
        if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Sort[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (filter_Field !== undefined)
            url_ += "Filter.Field=" + encodeURIComponent("" + filter_Field) + "&"; 
        if (filter_Operator !== undefined)
            url_ += "Filter.Operator=" + encodeURIComponent("" + filter_Operator) + "&"; 
        if (filter_Value !== undefined)
            url_ += "Filter.Value=" + encodeURIComponent("" + filter_Value) + "&"; 
        if (filter_Logic !== undefined)
            url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&"; 
        if (filter_Filters !== undefined)
            filter_Filters && filter_Filters.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filter.Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (countless !== undefined)
            url_ += "Countless=" + encodeURIComponent("" + countless) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_UserRole_GetAllDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_UserRole_GetAllDetails(<any>response_);
                } catch (e) {
                    return <Observable<DataSourceResultOfUserRoleDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSourceResultOfUserRoleDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApi_UserRole_GetAllDetails(response: HttpResponseBase): Observable<DataSourceResultOfUserRoleDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataSourceResultOfUserRoleDTO.fromJS(resultData200) : new DataSourceResultOfUserRoleDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSourceResultOfUserRoleDTO>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    api_UserRole_GetById(id: string | null | undefined): Observable<UserRoleDTO> {
        let url_ = this.baseUrl + "/api/UserRole/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_UserRole_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_UserRole_GetById(<any>response_);
                } catch (e) {
                    return <Observable<UserRoleDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserRoleDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApi_UserRole_GetById(response: HttpResponseBase): Observable<UserRoleDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserRoleDTO.fromJS(resultData200) : new UserRoleDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserRoleDTO>(<any>null);
    }

    /**
     * @param entities (optional) 
     * @return Success
     */
    api_UserRole_Insert(entities: UserRoleDTO[] | null | undefined): Observable<UserRoleDTO[]> {
        let url_ = this.baseUrl + "/api/UserRole/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entities);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_UserRole_Insert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_UserRole_Insert(<any>response_);
                } catch (e) {
                    return <Observable<UserRoleDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserRoleDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApi_UserRole_Insert(response: HttpResponseBase): Observable<UserRoleDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserRoleDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserRoleDTO[]>(<any>null);
    }

    /**
     * @param entities (optional) 
     * @return Success
     */
    api_UserRole_Update(entities: UserRoleDTO[] | null | undefined): Observable<UserRoleDTO[]> {
        let url_ = this.baseUrl + "/api/UserRole/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entities);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_UserRole_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_UserRole_Update(<any>response_);
                } catch (e) {
                    return <Observable<UserRoleDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserRoleDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApi_UserRole_Update(response: HttpResponseBase): Observable<UserRoleDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserRoleDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserRoleDTO[]>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    api_UserRole_Delete(ids: any[] | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/UserRole/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_UserRole_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_UserRole_Delete(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processApi_UserRole_Delete(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @param checkUniqueDTO (optional) 
     * @return Success
     */
    api_UserRole_IsExisted(checkUniqueDTO: CheckUniqueDTO | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/UserRole/IsExisted";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(checkUniqueDTO);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApi_UserRole_IsExisted(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApi_UserRole_IsExisted(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApi_UserRole_IsExisted(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

export class UserLoginDTO implements IUserLoginDTO {
    username!: string;
    password!: string;

    constructor(data?: IUserLoginDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.username = data["username"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): UserLoginDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        return data; 
    }
}

export interface IUserLoginDTO {
    username: string;
    password: string;
}

export class AccessToken implements IAccessToken {
    access_token?: string | undefined;
    refresh_token?: string | undefined;

    constructor(data?: IAccessToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.access_token = data["access_token"];
            this.refresh_token = data["refresh_token"];
        }
    }

    static fromJS(data: any): AccessToken {
        data = typeof data === 'object' ? data : {};
        let result = new AccessToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["access_token"] = this.access_token;
        data["refresh_token"] = this.refresh_token;
        return data; 
    }
}

export interface IAccessToken {
    access_token?: string | undefined;
    refresh_token?: string | undefined;
}

export class AuthTicketDTO implements IAuthTicketDTO {
    userName?: string | undefined;
    email?: string | undefined;
    fullName?: string | undefined;
    profileImageFileId?: number | undefined;
    organizationId?: number | undefined;
    organizationName?: string | undefined;
    roleId?: number | undefined;
    roleName?: string | undefined;
    defaultCulture?: string | undefined;
    defaultCalendar?: string | undefined;
    permissions?: string[] | undefined;
    userRoles?: UserRoleDTO[] | undefined;

    constructor(data?: IAuthTicketDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.email = data["email"];
            this.fullName = data["fullName"];
            this.profileImageFileId = data["profileImageFileId"];
            this.organizationId = data["organizationId"];
            this.organizationName = data["organizationName"];
            this.roleId = data["roleId"];
            this.roleName = data["roleName"];
            this.defaultCulture = data["defaultCulture"];
            this.defaultCalendar = data["defaultCalendar"];
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [] as any;
                for (let item of data["permissions"])
                    this.permissions!.push(item);
            }
            if (data["userRoles"] && data["userRoles"].constructor === Array) {
                this.userRoles = [] as any;
                for (let item of data["userRoles"])
                    this.userRoles!.push(UserRoleDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AuthTicketDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AuthTicketDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["fullName"] = this.fullName;
        data["profileImageFileId"] = this.profileImageFileId;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        data["defaultCulture"] = this.defaultCulture;
        data["defaultCalendar"] = this.defaultCalendar;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        if (this.userRoles && this.userRoles.constructor === Array) {
            data["userRoles"] = [];
            for (let item of this.userRoles)
                data["userRoles"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAuthTicketDTO {
    userName?: string | undefined;
    email?: string | undefined;
    fullName?: string | undefined;
    profileImageFileId?: number | undefined;
    organizationId?: number | undefined;
    organizationName?: string | undefined;
    roleId?: number | undefined;
    roleName?: string | undefined;
    defaultCulture?: string | undefined;
    defaultCalendar?: string | undefined;
    permissions?: string[] | undefined;
    userRoles?: UserRoleDTO[] | undefined;
}

export class UserRoleDTO implements IUserRoleDTO {
    userId?: number | undefined;
    roleId?: number | undefined;
    roleName?: string | undefined;
    enabledSince?: Date | undefined;
    enabledUntil?: Date | undefined;
    notes?: string | undefined;

    constructor(data?: IUserRoleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.roleId = data["roleId"];
            this.roleName = data["roleName"];
            this.enabledSince = data["enabledSince"] ? new Date(data["enabledSince"].toString()) : <any>undefined;
            this.enabledUntil = data["enabledUntil"] ? new Date(data["enabledUntil"].toString()) : <any>undefined;
            this.notes = data["notes"];
        }
    }

    static fromJS(data: any): UserRoleDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        data["enabledSince"] = this.enabledSince ? this.enabledSince.toISOString() : <any>undefined;
        data["enabledUntil"] = this.enabledUntil ? this.enabledUntil.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        return data; 
    }
}

export interface IUserRoleDTO {
    userId?: number | undefined;
    roleId?: number | undefined;
    roleName?: string | undefined;
    enabledSince?: Date | undefined;
    enabledUntil?: Date | undefined;
    notes?: string | undefined;
}

export class Sort implements ISort {
    field?: string | undefined;
    dir?: string | undefined;

    constructor(data?: ISort) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.field = data["field"];
            this.dir = data["dir"];
        }
    }

    static fromJS(data: any): Sort {
        data = typeof data === 'object' ? data : {};
        let result = new Sort();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["dir"] = this.dir;
        return data; 
    }
}

export interface ISort {
    field?: string | undefined;
    dir?: string | undefined;
}

export class Filter implements IFilter {
    field?: string | undefined;
    operator?: string | undefined;
    value?: string | undefined;
    logic?: string | undefined;
    filters?: Filter[] | undefined;

    constructor(data?: IFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.field = data["field"];
            this.operator = data["operator"];
            this.value = data["value"];
            this.logic = data["logic"];
            if (data["filters"] && data["filters"].constructor === Array) {
                this.filters = [] as any;
                for (let item of data["filters"])
                    this.filters!.push(Filter.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Filter {
        data = typeof data === 'object' ? data : {};
        let result = new Filter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["operator"] = this.operator;
        data["value"] = this.value;
        data["logic"] = this.logic;
        if (this.filters && this.filters.constructor === Array) {
            data["filters"] = [];
            for (let item of this.filters)
                data["filters"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IFilter {
    field?: string | undefined;
    operator?: string | undefined;
    value?: string | undefined;
    logic?: string | undefined;
    filters?: Filter[] | undefined;
}

export class DataSourceResultOfCategoryDTO implements IDataSourceResultOfCategoryDTO {
    data?: CategoryDTO[] | undefined;
    count?: number | undefined;

    constructor(data?: IDataSourceResultOfCategoryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [] as any;
                for (let item of data["data"])
                    this.data!.push(CategoryDTO.fromJS(item));
            }
            this.count = data["count"];
        }
    }

    static fromJS(data: any): DataSourceResultOfCategoryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DataSourceResultOfCategoryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        return data; 
    }
}

export interface IDataSourceResultOfCategoryDTO {
    data?: CategoryDTO[] | undefined;
    count?: number | undefined;
}

export class CategoryDTO implements ICategoryDTO {
    categoryId?: number | undefined;
    categoryNameAr?: string | undefined;
    categoryNameEn?: string | undefined;
    code?: string | undefined;

    constructor(data?: ICategoryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.categoryId = data["categoryId"];
            this.categoryNameAr = data["categoryNameAr"];
            this.categoryNameEn = data["categoryNameEn"];
            this.code = data["code"];
        }
    }

    static fromJS(data: any): CategoryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId;
        data["categoryNameAr"] = this.categoryNameAr;
        data["categoryNameEn"] = this.categoryNameEn;
        data["code"] = this.code;
        return data; 
    }
}

export interface ICategoryDTO {
    categoryId?: number | undefined;
    categoryNameAr?: string | undefined;
    categoryNameEn?: string | undefined;
    code?: string | undefined;
}

export class CheckUniqueDTO implements ICheckUniqueDTO {
    tableName?: string | undefined;
    fields?: string[] | undefined;
    values?: string[] | undefined;

    constructor(data?: ICheckUniqueDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tableName = data["tableName"];
            if (data["fields"] && data["fields"].constructor === Array) {
                this.fields = [] as any;
                for (let item of data["fields"])
                    this.fields!.push(item);
            }
            if (data["values"] && data["values"].constructor === Array) {
                this.values = [] as any;
                for (let item of data["values"])
                    this.values!.push(item);
            }
        }
    }

    static fromJS(data: any): CheckUniqueDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CheckUniqueDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tableName"] = this.tableName;
        if (this.fields && this.fields.constructor === Array) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item);
        }
        if (this.values && this.values.constructor === Array) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item);
        }
        return data; 
    }
}

export interface ICheckUniqueDTO {
    tableName?: string | undefined;
    fields?: string[] | undefined;
    values?: string[] | undefined;
}

export class DataSourceResultOfLocalizationDetailsDTO implements IDataSourceResultOfLocalizationDetailsDTO {
    data?: LocalizationDetailsDTO[] | undefined;
    count?: number | undefined;

    constructor(data?: IDataSourceResultOfLocalizationDetailsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [] as any;
                for (let item of data["data"])
                    this.data!.push(LocalizationDetailsDTO.fromJS(item));
            }
            this.count = data["count"];
        }
    }

    static fromJS(data: any): DataSourceResultOfLocalizationDetailsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DataSourceResultOfLocalizationDetailsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        return data; 
    }
}

export interface IDataSourceResultOfLocalizationDetailsDTO {
    data?: LocalizationDetailsDTO[] | undefined;
    count?: number | undefined;
}

export class LocalizationDetailsDTO implements ILocalizationDetailsDTO {
    localizationId?: number | undefined;
    key?: string | undefined;
    valueAr?: string | undefined;
    valueEn?: string | undefined;

    constructor(data?: ILocalizationDetailsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.localizationId = data["localizationId"];
            this.key = data["key"];
            this.valueAr = data["valueAr"];
            this.valueEn = data["valueEn"];
        }
    }

    static fromJS(data: any): LocalizationDetailsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizationDetailsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["localizationId"] = this.localizationId;
        data["key"] = this.key;
        data["valueAr"] = this.valueAr;
        data["valueEn"] = this.valueEn;
        return data; 
    }
}

export interface ILocalizationDetailsDTO {
    localizationId?: number | undefined;
    key?: string | undefined;
    valueAr?: string | undefined;
    valueEn?: string | undefined;
}

export class Lookup implements ILookup {
    id?: any | undefined;
    text?: string | undefined;
    children?: Lookup[] | undefined;
    additional?: LookupAdditional | undefined;

    constructor(data?: ILookup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.text = data["text"];
            if (data["children"] && data["children"].constructor === Array) {
                this.children = [] as any;
                for (let item of data["children"])
                    this.children!.push(Lookup.fromJS(item));
            }
            this.additional = data["additional"] ? LookupAdditional.fromJS(data["additional"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Lookup {
        data = typeof data === 'object' ? data : {};
        let result = new Lookup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["text"] = this.text;
        if (this.children && this.children.constructor === Array) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        data["additional"] = this.additional ? this.additional.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ILookup {
    id?: any | undefined;
    text?: string | undefined;
    children?: Lookup[] | undefined;
    additional?: LookupAdditional | undefined;
}

export class LookupAdditional implements ILookupAdditional {
    description?: string | undefined;
    imageId?: number | undefined;
    imageUrl?: string | undefined;
    image?: string | undefined;
    ancestors?: Lookup[] | undefined;
    data?: any | undefined;

    constructor(data?: ILookupAdditional) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.imageId = data["imageId"];
            this.imageUrl = data["imageUrl"];
            this.image = data["image"];
            if (data["ancestors"] && data["ancestors"].constructor === Array) {
                this.ancestors = [] as any;
                for (let item of data["ancestors"])
                    this.ancestors!.push(Lookup.fromJS(item));
            }
            this.data = data["data"];
        }
    }

    static fromJS(data: any): LookupAdditional {
        data = typeof data === 'object' ? data : {};
        let result = new LookupAdditional();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["imageId"] = this.imageId;
        data["imageUrl"] = this.imageUrl;
        data["image"] = this.image;
        if (this.ancestors && this.ancestors.constructor === Array) {
            data["ancestors"] = [];
            for (let item of this.ancestors)
                data["ancestors"].push(item.toJSON());
        }
        data["data"] = this.data;
        return data; 
    }
}

export interface ILookupAdditional {
    description?: string | undefined;
    imageId?: number | undefined;
    imageUrl?: string | undefined;
    image?: string | undefined;
    ancestors?: Lookup[] | undefined;
    data?: any | undefined;
}

export class DataSourceResultOfRoleDTO implements IDataSourceResultOfRoleDTO {
    data?: RoleDTO[] | undefined;
    count?: number | undefined;

    constructor(data?: IDataSourceResultOfRoleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [] as any;
                for (let item of data["data"])
                    this.data!.push(RoleDTO.fromJS(item));
            }
            this.count = data["count"];
        }
    }

    static fromJS(data: any): DataSourceResultOfRoleDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DataSourceResultOfRoleDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        return data; 
    }
}

export interface IDataSourceResultOfRoleDTO {
    data?: RoleDTO[] | undefined;
    count?: number | undefined;
}

export class RoleDTO implements IRoleDTO {
    roleId?: number | undefined;
    roleName?: string | undefined;
    roleNameAr?: string | undefined;
    roleNameEn?: string | undefined;

    constructor(data?: IRoleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            this.roleName = data["roleName"];
            this.roleNameAr = data["roleNameAr"];
            this.roleNameEn = data["roleNameEn"];
        }
    }

    static fromJS(data: any): RoleDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        data["roleNameAr"] = this.roleNameAr;
        data["roleNameEn"] = this.roleNameEn;
        return data; 
    }
}

export interface IRoleDTO {
    roleId?: number | undefined;
    roleName?: string | undefined;
    roleNameAr?: string | undefined;
    roleNameEn?: string | undefined;
}

export class UserDetailsDTO implements IUserDetailsDTO {
    userId?: number | undefined;
    concurrencyStamp?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    faxNumber?: string | undefined;
    userName?: string | undefined;
    fullNameEn?: string | undefined;
    fullNameAr?: string | undefined;
    enabled?: boolean | undefined;
    enabledUntil?: Date | undefined;
    profileImage?: string | undefined;
    signatureFileId?: number | undefined;
    trkeenFileId?: number | undefined;
    stampFileId?: number | undefined;
    employeeNumber?: string | undefined;
    ssn?: string | undefined;
    passportNumber?: string | undefined;
    password?: string | undefined;
    iqamaNumber?: string | undefined;
    genderId?: number | undefined;
    genderName?: string | undefined;
    nationalityId?: number | undefined;
    nationalityName?: string | undefined;
    jobTitleId?: number | undefined;
    jobTitleName?: string | undefined;
    workPlaceId?: number | undefined;
    workPlaceName?: string | undefined;
    address?: string | undefined;
    defaultCulture?: string | undefined;
    defaultCalendar?: string | undefined;
    workPhoneNumber?: string | undefined;
    notificationByMail?: boolean | undefined;
    notificationBySMS?: boolean | undefined;
    isIndividual?: boolean | undefined;
    isEmployee?: boolean | undefined;
    isCorrespondentForAllOrganizations?: boolean | undefined;

    constructor(data?: IUserDetailsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.concurrencyStamp = data["concurrencyStamp"];
            this.email = data["email"];
            this.phoneNumber = data["phoneNumber"];
            this.faxNumber = data["faxNumber"];
            this.userName = data["userName"];
            this.fullNameEn = data["fullNameEn"];
            this.fullNameAr = data["fullNameAr"];
            this.enabled = data["enabled"];
            this.enabledUntil = data["enabledUntil"] ? new Date(data["enabledUntil"].toString()) : <any>undefined;
            this.profileImage = data["profileImage"];
            this.signatureFileId = data["signatureFileId"];
            this.trkeenFileId = data["trkeenFileId"];
            this.stampFileId = data["stampFileId"];
            this.employeeNumber = data["employeeNumber"];
            this.ssn = data["ssn"];
            this.passportNumber = data["passportNumber"];
            this.password = data["password"];
            this.iqamaNumber = data["iqamaNumber"];
            this.genderId = data["genderId"];
            this.genderName = data["genderName"];
            this.nationalityId = data["nationalityId"];
            this.nationalityName = data["nationalityName"];
            this.jobTitleId = data["jobTitleId"];
            this.jobTitleName = data["jobTitleName"];
            this.workPlaceId = data["workPlaceId"];
            this.workPlaceName = data["workPlaceName"];
            this.address = data["address"];
            this.defaultCulture = data["defaultCulture"];
            this.defaultCalendar = data["defaultCalendar"];
            this.workPhoneNumber = data["workPhoneNumber"];
            this.notificationByMail = data["notificationByMail"];
            this.notificationBySMS = data["notificationBySMS"];
            this.isIndividual = data["isIndividual"];
            this.isEmployee = data["isEmployee"];
            this.isCorrespondentForAllOrganizations = data["isCorrespondentForAllOrganizations"];
        }
    }

    static fromJS(data: any): UserDetailsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UserDetailsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["concurrencyStamp"] = this.concurrencyStamp;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["faxNumber"] = this.faxNumber;
        data["userName"] = this.userName;
        data["fullNameEn"] = this.fullNameEn;
        data["fullNameAr"] = this.fullNameAr;
        data["enabled"] = this.enabled;
        data["enabledUntil"] = this.enabledUntil ? this.enabledUntil.toISOString() : <any>undefined;
        data["profileImage"] = this.profileImage;
        data["signatureFileId"] = this.signatureFileId;
        data["trkeenFileId"] = this.trkeenFileId;
        data["stampFileId"] = this.stampFileId;
        data["employeeNumber"] = this.employeeNumber;
        data["ssn"] = this.ssn;
        data["passportNumber"] = this.passportNumber;
        data["password"] = this.password;
        data["iqamaNumber"] = this.iqamaNumber;
        data["genderId"] = this.genderId;
        data["genderName"] = this.genderName;
        data["nationalityId"] = this.nationalityId;
        data["nationalityName"] = this.nationalityName;
        data["jobTitleId"] = this.jobTitleId;
        data["jobTitleName"] = this.jobTitleName;
        data["workPlaceId"] = this.workPlaceId;
        data["workPlaceName"] = this.workPlaceName;
        data["address"] = this.address;
        data["defaultCulture"] = this.defaultCulture;
        data["defaultCalendar"] = this.defaultCalendar;
        data["workPhoneNumber"] = this.workPhoneNumber;
        data["notificationByMail"] = this.notificationByMail;
        data["notificationBySMS"] = this.notificationBySMS;
        data["isIndividual"] = this.isIndividual;
        data["isEmployee"] = this.isEmployee;
        data["isCorrespondentForAllOrganizations"] = this.isCorrespondentForAllOrganizations;
        return data; 
    }
}

export interface IUserDetailsDTO {
    userId?: number | undefined;
    concurrencyStamp?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    faxNumber?: string | undefined;
    userName?: string | undefined;
    fullNameEn?: string | undefined;
    fullNameAr?: string | undefined;
    enabled?: boolean | undefined;
    enabledUntil?: Date | undefined;
    profileImage?: string | undefined;
    signatureFileId?: number | undefined;
    trkeenFileId?: number | undefined;
    stampFileId?: number | undefined;
    employeeNumber?: string | undefined;
    ssn?: string | undefined;
    passportNumber?: string | undefined;
    password?: string | undefined;
    iqamaNumber?: string | undefined;
    genderId?: number | undefined;
    genderName?: string | undefined;
    nationalityId?: number | undefined;
    nationalityName?: string | undefined;
    jobTitleId?: number | undefined;
    jobTitleName?: string | undefined;
    workPlaceId?: number | undefined;
    workPlaceName?: string | undefined;
    address?: string | undefined;
    defaultCulture?: string | undefined;
    defaultCalendar?: string | undefined;
    workPhoneNumber?: string | undefined;
    notificationByMail?: boolean | undefined;
    notificationBySMS?: boolean | undefined;
    isIndividual?: boolean | undefined;
    isEmployee?: boolean | undefined;
    isCorrespondentForAllOrganizations?: boolean | undefined;
}

export class ChangePasswordViewModel implements IChangePasswordViewModel {
    oldPassword!: string;
    newPassword!: string;
    confirmPassword!: string;

    constructor(data?: IChangePasswordViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.oldPassword = data["oldPassword"];
            this.newPassword = data["newPassword"];
            this.confirmPassword = data["confirmPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["oldPassword"] = this.oldPassword;
        data["newPassword"] = this.newPassword;
        data["confirmPassword"] = this.confirmPassword;
        return data; 
    }
}

export interface IChangePasswordViewModel {
    oldPassword: string;
    newPassword: string;
    confirmPassword: string;
}

export class DataSourceResultOfUserSummaryDTO implements IDataSourceResultOfUserSummaryDTO {
    data?: UserSummaryDTO[] | undefined;
    count?: number | undefined;

    constructor(data?: IDataSourceResultOfUserSummaryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [] as any;
                for (let item of data["data"])
                    this.data!.push(UserSummaryDTO.fromJS(item));
            }
            this.count = data["count"];
        }
    }

    static fromJS(data: any): DataSourceResultOfUserSummaryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DataSourceResultOfUserSummaryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        return data; 
    }
}

export interface IDataSourceResultOfUserSummaryDTO {
    data?: UserSummaryDTO[] | undefined;
    count?: number | undefined;
}

export class UserSummaryDTO implements IUserSummaryDTO {
    id?: number | undefined;
    userName?: string | undefined;
    fullName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    enabled?: boolean | undefined;
    profileImage?: string | undefined;

    constructor(data?: IUserSummaryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.userName = data["userName"];
            this.fullName = data["fullName"];
            this.email = data["email"];
            this.phoneNumber = data["phoneNumber"];
            this.enabled = data["enabled"];
            this.profileImage = data["profileImage"];
        }
    }

    static fromJS(data: any): UserSummaryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UserSummaryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["fullName"] = this.fullName;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["enabled"] = this.enabled;
        data["profileImage"] = this.profileImage;
        return data; 
    }
}

export interface IUserSummaryDTO {
    id?: number | undefined;
    userName?: string | undefined;
    fullName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    enabled?: boolean | undefined;
    profileImage?: string | undefined;
}

export class DataSourceResultOfUserDetailsDTO implements IDataSourceResultOfUserDetailsDTO {
    data?: UserDetailsDTO[] | undefined;
    count?: number | undefined;

    constructor(data?: IDataSourceResultOfUserDetailsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [] as any;
                for (let item of data["data"])
                    this.data!.push(UserDetailsDTO.fromJS(item));
            }
            this.count = data["count"];
        }
    }

    static fromJS(data: any): DataSourceResultOfUserDetailsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DataSourceResultOfUserDetailsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        return data; 
    }
}

export interface IDataSourceResultOfUserDetailsDTO {
    data?: UserDetailsDTO[] | undefined;
    count?: number | undefined;
}

export class DataSourceResultOfUserRoleDTO implements IDataSourceResultOfUserRoleDTO {
    data?: UserRoleDTO[] | undefined;
    count?: number | undefined;

    constructor(data?: IDataSourceResultOfUserRoleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [] as any;
                for (let item of data["data"])
                    this.data!.push(UserRoleDTO.fromJS(item));
            }
            this.count = data["count"];
        }
    }

    static fromJS(data: any): DataSourceResultOfUserRoleDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DataSourceResultOfUserRoleDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        return data; 
    }
}

export interface IDataSourceResultOfUserRoleDTO {
    data?: UserRoleDTO[] | undefined;
    count?: number | undefined;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}